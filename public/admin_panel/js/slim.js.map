{"version":3,"sources":["slim.kickstart.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"slim.js","sourcesContent":["/*\n * Slim v1.1.1 - Image Cropping Made Easy\n * Copyright (c) 2016 Rik Schennink - http://slim.pqina.nl\n */\n(function(root,undefined){\n\n    // Cut the mustard for really old browsers\n    if (!root || !root.addEventListener) {return;}\n\n    // Slim lib\n    root.Slim = function() {\n\n/*\n* JavaScript Load Image\n* https://github.com/blueimp/JavaScript-Load-Image\n*\n* Copyright 2011, Sebastian Tschan\n* https://blueimp.net\n*\n* Licensed under the MIT license:\n* http://www.opensource.org/licenses/MIT\n*/\n\n/*global define, module, window, document, URL, webkitURL, FileReader */\n\n// Loads an image for a given File object.\n// Invokes the callback with an img or optional canvas\n// element (if supported by the browser) as parameter:\nvar loadImage = function (file, callback, options) {\n    var img = document.createElement('img')\n    var url\n    var oUrl\n    img.onerror = callback\n    img.onload = function () {\n        if (oUrl && !(options && options.noRevoke)) {\n            loadImage.revokeObjectURL(oUrl)\n        }\n        if (callback) {\n            callback(loadImage.scale(img, options))\n        }\n    }\n    if (loadImage.isInstanceOf('Blob', file) ||\n        // Files are also Blob instances, but some browsers\n        // (Firefox 3.6) support the File API but not Blobs:\n        loadImage.isInstanceOf('File', file)) {\n        url = oUrl = loadImage.createObjectURL(file)\n        // Store the file type for resize processing:\n        img._type = file.type\n    } else if (typeof file === 'string') {\n        url = file\n        if (options && options.crossOrigin) {\n            img.crossOrigin = options.crossOrigin\n        }\n    } else {\n        return false\n    }\n    if (url) {\n        img.src = url\n        return img\n    }\n    return loadImage.readFile(file, function (e) {\n        var target = e.target\n        if (target && target.result) {\n            img.src = target.result\n        } else {\n            if (callback) {\n                callback(e)\n            }\n        }\n    })\n}\n// The check for URL.revokeObjectURL fixes an issue with Opera 12,\n// which provides URL.createObjectURL but doesn't properly implement it:\nvar urlAPI = (window.createObjectURL && window) ||\n    (window.URL && URL.revokeObjectURL && URL) ||\n    (window.webkitURL && webkitURL)\n\nloadImage.isInstanceOf = function (type, obj) {\n    // Cross-frame instanceof check\n    return Object.prototype.toString.call(obj) === '[object ' + type + ']'\n}\n\n// Transform image coordinates, allows to override e.g.\n// the canvas orientation based on the orientation option,\n// gets canvas, options passed as arguments:\nloadImage.transformCoordinates = function () {\n    return\n}\n\n// Returns transformed options, allows to override e.g.\n// maxWidth, maxHeight and crop options based on the aspectRatio.\n// gets img, options passed as arguments:\nloadImage.getTransformedOptions = function (img, options) {\n    var aspectRatio = options.aspectRatio\n    var newOptions\n    var i\n    var width\n    var height\n    if (!aspectRatio) {\n        return options\n    }\n    newOptions = {}\n    for (i in options) {\n        if (options.hasOwnProperty(i)) {\n            newOptions[i] = options[i]\n        }\n    }\n    newOptions.crop = true\n    width = img.naturalWidth || img.width\n    height = img.naturalHeight || img.height\n    if (width / height > aspectRatio) {\n        newOptions.maxWidth = height * aspectRatio\n        newOptions.maxHeight = height\n    } else {\n        newOptions.maxWidth = width\n        newOptions.maxHeight = width / aspectRatio\n    }\n    return newOptions\n}\n\n// Canvas render method, allows to implement a different rendering algorithm:\nloadImage.renderImageToCanvas = function (\n    canvas,\n    img,\n    sourceX,\n    sourceY,\n    sourceWidth,\n    sourceHeight,\n    destX,\n    destY,\n    destWidth,\n    destHeight\n) {\n    canvas.getContext('2d').drawImage(\n        img,\n        sourceX,\n        sourceY,\n        sourceWidth,\n        sourceHeight,\n        destX,\n        destY,\n        destWidth,\n        destHeight\n    )\n    return canvas\n}\n\n// This method is used to determine if the target image\n// should be a canvas element:\nloadImage.hasCanvasOption = function (options) {\n    return options.canvas || options.crop || !!options.aspectRatio\n}\n\n// Scales and/or crops the given image (img or canvas HTML element)\n// using the given options.\n// Returns a canvas object if the browser supports canvas\n// and the hasCanvasOption method returns true or a canvas\n// object is passed as image, else the scaled image:\nloadImage.scale = function (img, options) {\n    options = options || {}\n    var canvas = document.createElement('canvas')\n    var useCanvas = img.getContext ||\n        (loadImage.hasCanvasOption(options) && canvas.getContext)\n    var width = img.naturalWidth || img.width\n    var height = img.naturalHeight || img.height\n    var destWidth = width\n    var destHeight = height\n    var maxWidth\n    var maxHeight\n    var minWidth\n    var minHeight\n    var sourceWidth\n    var sourceHeight\n    var sourceX\n    var sourceY\n    var pixelRatio\n    var downsamplingRatio\n    var tmp\n    function scaleUp () {\n        var scale = Math.max(\n            (minWidth || destWidth) / destWidth,\n            (minHeight || destHeight) / destHeight\n        )\n        if (scale > 1) {\n            destWidth *= scale\n            destHeight *= scale\n        }\n    }\n    function scaleDown () {\n        var scale = Math.min(\n            (maxWidth || destWidth) / destWidth,\n            (maxHeight || destHeight) / destHeight\n        )\n        if (scale < 1) {\n            destWidth *= scale\n            destHeight *= scale\n        }\n    }\n    if (useCanvas) {\n        options = loadImage.getTransformedOptions(img, options)\n        sourceX = options.left || 0\n        sourceY = options.top || 0\n        if (options.sourceWidth) {\n            sourceWidth = options.sourceWidth\n            if (options.right !== undefined && options.left === undefined) {\n                sourceX = width - sourceWidth - options.right\n            }\n        } else {\n            sourceWidth = width - sourceX - (options.right || 0)\n        }\n        if (options.sourceHeight) {\n            sourceHeight = options.sourceHeight\n            if (options.bottom !== undefined && options.top === undefined) {\n                sourceY = height - sourceHeight - options.bottom\n            }\n        } else {\n            sourceHeight = height - sourceY - (options.bottom || 0)\n        }\n        destWidth = sourceWidth\n        destHeight = sourceHeight\n    }\n    maxWidth = options.maxWidth\n    maxHeight = options.maxHeight\n    minWidth = options.minWidth\n    minHeight = options.minHeight\n    if (useCanvas && maxWidth && maxHeight && options.crop) {\n        destWidth = maxWidth\n        destHeight = maxHeight\n        tmp = sourceWidth / sourceHeight - maxWidth / maxHeight\n        if (tmp < 0) {\n            sourceHeight = maxHeight * sourceWidth / maxWidth\n            if (options.top === undefined && options.bottom === undefined) {\n                sourceY = (height - sourceHeight) / 2\n            }\n        } else if (tmp > 0) {\n            sourceWidth = maxWidth * sourceHeight / maxHeight\n            if (options.left === undefined && options.right === undefined) {\n                sourceX = (width - sourceWidth) / 2\n            }\n        }\n    } else {\n        if (options.contain || options.cover) {\n            minWidth = maxWidth = maxWidth || minWidth\n            minHeight = maxHeight = maxHeight || minHeight\n        }\n        if (options.cover) {\n            scaleDown()\n            scaleUp()\n        } else {\n            scaleUp()\n            scaleDown()\n        }\n    }\n    if (useCanvas) {\n        pixelRatio = options.pixelRatio\n        if (pixelRatio > 1) {\n            canvas.style.width = destWidth + 'px'\n            canvas.style.height = destHeight + 'px'\n            destWidth *= pixelRatio\n            destHeight *= pixelRatio\n            canvas.getContext('2d').scale(pixelRatio, pixelRatio)\n        }\n        downsamplingRatio = options.downsamplingRatio\n        if (downsamplingRatio > 0 && downsamplingRatio < 1 &&\n            destWidth < sourceWidth && destHeight < sourceHeight) {\n            while (sourceWidth * downsamplingRatio > destWidth) {\n                canvas.width = sourceWidth * downsamplingRatio\n                canvas.height = sourceHeight * downsamplingRatio\n                loadImage.renderImageToCanvas(\n                    canvas,\n                    img,\n                    sourceX,\n                    sourceY,\n                    sourceWidth,\n                    sourceHeight,\n                    0,\n                    0,\n                    canvas.width,\n                    canvas.height\n                )\n                sourceWidth = canvas.width\n                sourceHeight = canvas.height\n                img = document.createElement('canvas')\n                img.width = sourceWidth\n                img.height = sourceHeight\n                loadImage.renderImageToCanvas(\n                    img,\n                    canvas,\n                    0,\n                    0,\n                    sourceWidth,\n                    sourceHeight,\n                    0,\n                    0,\n                    sourceWidth,\n                    sourceHeight\n                )\n            }\n        }\n        canvas.width = destWidth\n        canvas.height = destHeight\n        loadImage.transformCoordinates(\n            canvas,\n            options\n        )\n        return loadImage.renderImageToCanvas(\n            canvas,\n            img,\n            sourceX,\n            sourceY,\n            sourceWidth,\n            sourceHeight,\n            0,\n            0,\n            destWidth,\n            destHeight\n        )\n    }\n    img.width = destWidth\n    img.height = destHeight\n    return img\n}\n\nloadImage.createObjectURL = function (file) {\n    return urlAPI ? urlAPI.createObjectURL(file) : false\n}\n\nloadImage.revokeObjectURL = function (url) {\n    return urlAPI ? urlAPI.revokeObjectURL(url) : false\n}\n\n// Loads a given File object via FileReader interface,\n// invokes the callback with the event object (load or error).\n// The result can be read via event.target.result:\nloadImage.readFile = function (file, callback, method) {\n    if (window.FileReader) {\n        var fileReader = new FileReader()\n        fileReader.onload = fileReader.onerror = callback\n        method = method || 'readAsDataURL'\n        if (fileReader[method]) {\n            fileReader[method](file)\n            return fileReader\n        }\n    }\n    return false\n}\n\nvar originalHasCanvasOption = loadImage.hasCanvasOption\nvar originalTransformCoordinates = loadImage.transformCoordinates\nvar originalGetTransformedOptions = loadImage.getTransformedOptions\n\n// This method is used to determine if the target image\n// should be a canvas element:\nloadImage.hasCanvasOption = function (options) {\n    return !!options.orientation ||\n        originalHasCanvasOption.call(loadImage, options)\n}\n\n// Transform image orientation based on\n// the given EXIF orientation option:\nloadImage.transformCoordinates = function (canvas, options) {\n    originalTransformCoordinates.call(loadImage, canvas, options)\n    var ctx = canvas.getContext('2d')\n    var width = canvas.width\n    var height = canvas.height\n    var styleWidth = canvas.style.width\n    var styleHeight = canvas.style.height\n    var orientation = options.orientation\n    if (!orientation || orientation > 8) {\n        return\n    }\n    if (orientation > 4) {\n        canvas.width = height\n        canvas.height = width\n        canvas.style.width = styleHeight\n        canvas.style.height = styleWidth\n    }\n    switch (orientation) {\n        case 2:\n            // horizontal flip\n            ctx.translate(width, 0)\n            ctx.scale(-1, 1)\n            break\n        case 3:\n            // 180° rotate left\n            ctx.translate(width, height)\n            ctx.rotate(Math.PI)\n            break\n        case 4:\n            // vertical flip\n            ctx.translate(0, height)\n            ctx.scale(1, -1)\n            break\n        case 5:\n            // vertical flip + 90 rotate right\n            ctx.rotate(0.5 * Math.PI)\n            ctx.scale(1, -1)\n            break\n        case 6:\n            // 90° rotate right\n            ctx.rotate(0.5 * Math.PI)\n            ctx.translate(0, -height)\n            break\n        case 7:\n            // horizontal flip + 90 rotate right\n            ctx.rotate(0.5 * Math.PI)\n            ctx.translate(width, -height)\n            ctx.scale(-1, 1)\n            break\n        case 8:\n            // 90° rotate left\n            ctx.rotate(-0.5 * Math.PI)\n            ctx.translate(-width, 0)\n            break\n    }\n}\n\n// Transforms coordinate and dimension options\n// based on the given orientation option:\nloadImage.getTransformedOptions = function (img, opts) {\n    var options = originalGetTransformedOptions.call(loadImage, img, opts)\n    var orientation = options.orientation\n    var newOptions\n    var i\n    if (!orientation || orientation > 8 || orientation === 1) {\n        return options\n    }\n    newOptions = {}\n    for (i in options) {\n        if (options.hasOwnProperty(i)) {\n            newOptions[i] = options[i]\n        }\n    }\n    switch (options.orientation) {\n        case 2:\n            // horizontal flip\n            newOptions.left = options.right\n            newOptions.right = options.left\n            break\n        case 3:\n            // 180° rotate left\n            newOptions.left = options.right\n            newOptions.top = options.bottom\n            newOptions.right = options.left\n            newOptions.bottom = options.top\n            break\n        case 4:\n            // vertical flip\n            newOptions.top = options.bottom\n            newOptions.bottom = options.top\n            break\n        case 5:\n            // vertical flip + 90 rotate right\n            newOptions.left = options.top\n            newOptions.top = options.left\n            newOptions.right = options.bottom\n            newOptions.bottom = options.right\n            break\n        case 6:\n            // 90° rotate right\n            newOptions.left = options.top\n            newOptions.top = options.right\n            newOptions.right = options.bottom\n            newOptions.bottom = options.left\n            break\n        case 7:\n            // horizontal flip + 90 rotate right\n            newOptions.left = options.bottom\n            newOptions.top = options.right\n            newOptions.right = options.top\n            newOptions.bottom = options.left\n            break\n        case 8:\n            // 90° rotate left\n            newOptions.left = options.bottom\n            newOptions.top = options.left\n            newOptions.right = options.top\n            newOptions.bottom = options.right\n            break\n    }\n    if (options.orientation > 4) {\n        newOptions.maxWidth = options.maxHeight\n        newOptions.maxHeight = options.maxWidth\n        newOptions.minWidth = options.minHeight\n        newOptions.minHeight = options.minWidth\n        newOptions.sourceWidth = options.sourceHeight\n        newOptions.sourceHeight = options.sourceWidth\n    }\n    return newOptions\n}\n\nvar hasblobSlice = window.Blob && (Blob.prototype.slice ||\n    Blob.prototype.webkitSlice || Blob.prototype.mozSlice)\n\nloadImage.blobSlice = hasblobSlice && function () {\n        var slice = this.slice || this.webkitSlice || this.mozSlice\n        return slice.apply(this, arguments)\n    }\n\nloadImage.metaDataParsers = {\n    jpeg: {\n        0xffe1: [] // APP1 marker\n    }\n}\n\n// Parses image meta data and calls the callback with an object argument\n// with the following properties:\n// * imageHead: The complete image head as ArrayBuffer (Uint8Array for IE10)\n// The options arguments accepts an object and supports the following properties:\n// * maxMetaDataSize: Defines the maximum number of bytes to parse.\n// * disableImageHead: Disables creating the imageHead property.\nloadImage.parseMetaData = function (file, callback, options) {\n    options = options || {}\n    var that = this\n    // 256 KiB should contain all EXIF/ICC/IPTC segments:\n    var maxMetaDataSize = options.maxMetaDataSize || 262144\n    var data = {}\n    var noMetaData = !(window.DataView && file && file.size >= 12 &&\n    file.type === 'image/jpeg' && loadImage.blobSlice)\n    if (noMetaData || !loadImage.readFile(\n            loadImage.blobSlice.call(file, 0, maxMetaDataSize),\n            function (e) {\n                if (e.target.error) {\n                    // FileReader error\n                    console.log(e.target.error)\n                    callback(data)\n                    return\n                }\n                // Note on endianness:\n                // Since the marker and length bytes in JPEG files are always\n                // stored in big endian order, we can leave the endian parameter\n                // of the DataView methods undefined, defaulting to big endian.\n                var buffer = e.target.result\n                var dataView = new DataView(buffer)\n                var offset = 2\n                var maxOffset = dataView.byteLength - 4\n                var headLength = offset\n                var markerBytes\n                var markerLength\n                var parsers\n                var i\n                // Check for the JPEG marker (0xffd8):\n                if (dataView.getUint16(0) === 0xffd8) {\n                    while (offset < maxOffset) {\n                        markerBytes = dataView.getUint16(offset)\n                        // Search for APPn (0xffeN) and COM (0xfffe) markers,\n                        // which contain application-specific meta-data like\n                        // Exif, ICC and IPTC data and text comments:\n                        if ((markerBytes >= 0xffe0 && markerBytes <= 0xffef) ||\n                            markerBytes === 0xfffe) {\n                            // The marker bytes (2) are always followed by\n                            // the length bytes (2), indicating the length of the\n                            // marker segment, which includes the length bytes,\n                            // but not the marker bytes, so we add 2:\n                            markerLength = dataView.getUint16(offset + 2) + 2\n                            if (offset + markerLength > dataView.byteLength) {\n                                console.log('Invalid meta data: Invalid segment size.')\n                                break\n                            }\n                            parsers = loadImage.metaDataParsers.jpeg[markerBytes]\n                            if (parsers) {\n                                for (i = 0; i < parsers.length; i += 1) {\n                                    parsers[i].call(\n                                        that,\n                                        dataView,\n                                        offset,\n                                        markerLength,\n                                        data,\n                                        options\n                                    )\n                                }\n                            }\n                            offset += markerLength\n                            headLength = offset\n                        } else {\n                            // Not an APPn or COM marker, probably safe to\n                            // assume that this is the end of the meta data\n                            break\n                        }\n                    }\n                    // Meta length must be longer than JPEG marker (2)\n                    // plus APPn marker (2), followed by length bytes (2):\n                    if (!options.disableImageHead && headLength > 6) {\n                        if (buffer.slice) {\n                            data.imageHead = buffer.slice(0, headLength)\n                        } else {\n                            // Workaround for IE10, which does not yet\n                            // support ArrayBuffer.slice:\n                            data.imageHead = new Uint8Array(buffer)\n                                .subarray(0, headLength)\n                        }\n                    }\n                } else {\n                    console.log('Invalid JPEG file: Missing JPEG marker.')\n                }\n                callback(data)\n            },\n            'readAsArrayBuffer'\n        )) {\n        callback(data)\n    }\n}\n\nloadImage.ExifMap = function () {\n    return this\n}\n\nloadImage.ExifMap.prototype.map = {\n    'Orientation': 0x0112\n}\n\nloadImage.ExifMap.prototype.get = function (id) {\n    return this[id] || this[this.map[id]]\n}\n\nloadImage.getExifThumbnail = function (dataView, offset, length) {\n    var hexData,\n        i,\n        b\n    if (!length || offset + length > dataView.byteLength) {\n        console.log('Invalid Exif data: Invalid thumbnail data.')\n        return\n    }\n    hexData = []\n    for (i = 0; i < length; i += 1) {\n        b = dataView.getUint8(offset + i)\n        hexData.push((b < 16 ? '0' : '') + b.toString(16))\n    }\n    return 'data:image/jpeg,%' + hexData.join('%')\n}\n\nloadImage.exifTagTypes = {\n    // byte, 8-bit unsigned int:\n    1: {\n        getValue: function (dataView, dataOffset) {\n            return dataView.getUint8(dataOffset)\n        },\n        size: 1\n    },\n    // ascii, 8-bit byte:\n    2: {\n        getValue: function (dataView, dataOffset) {\n            return String.fromCharCode(dataView.getUint8(dataOffset))\n        },\n        size: 1,\n        ascii: true\n    },\n    // short, 16 bit int:\n    3: {\n        getValue: function (dataView, dataOffset, littleEndian) {\n            return dataView.getUint16(dataOffset, littleEndian)\n        },\n        size: 2\n    },\n    // long, 32 bit int:\n    4: {\n        getValue: function (dataView, dataOffset, littleEndian) {\n            return dataView.getUint32(dataOffset, littleEndian)\n        },\n        size: 4\n    },\n    // rational = two long values, first is numerator, second is denominator:\n    5: {\n        getValue: function (dataView, dataOffset, littleEndian) {\n            return dataView.getUint32(dataOffset, littleEndian) /\n                dataView.getUint32(dataOffset + 4, littleEndian)\n        },\n        size: 8\n    },\n    // slong, 32 bit signed int:\n    9: {\n        getValue: function (dataView, dataOffset, littleEndian) {\n            return dataView.getInt32(dataOffset, littleEndian)\n        },\n        size: 4\n    },\n    // srational, two slongs, first is numerator, second is denominator:\n    10: {\n        getValue: function (dataView, dataOffset, littleEndian) {\n            return dataView.getInt32(dataOffset, littleEndian) /\n                dataView.getInt32(dataOffset + 4, littleEndian)\n        },\n        size: 8\n    }\n}\n// undefined, 8-bit byte, value depending on field:\nloadImage.exifTagTypes[7] = loadImage.exifTagTypes[1]\n\nloadImage.getExifValue = function (dataView, tiffOffset, offset, type, length, littleEndian) {\n    var tagType = loadImage.exifTagTypes[type]\n    var tagSize\n    var dataOffset\n    var values\n    var i\n    var str\n    var c\n    if (!tagType) {\n        console.log('Invalid Exif data: Invalid tag type.')\n        return\n    }\n    tagSize = tagType.size * length\n    // Determine if the value is contained in the dataOffset bytes,\n    // or if the value at the dataOffset is a pointer to the actual data:\n    dataOffset = tagSize > 4\n        ? tiffOffset + dataView.getUint32(offset + 8, littleEndian)\n        : (offset + 8)\n    if (dataOffset + tagSize > dataView.byteLength) {\n        console.log('Invalid Exif data: Invalid data offset.')\n        return\n    }\n    if (length === 1) {\n        return tagType.getValue(dataView, dataOffset, littleEndian)\n    }\n    values = []\n    for (i = 0; i < length; i += 1) {\n        values[i] = tagType.getValue(dataView, dataOffset + i * tagType.size, littleEndian)\n    }\n    if (tagType.ascii) {\n        str = ''\n        // Concatenate the chars:\n        for (i = 0; i < values.length; i += 1) {\n            c = values[i]\n            // Ignore the terminating NULL byte(s):\n            if (c === '\\u0000') {\n                break\n            }\n            str += c\n        }\n        return str\n    }\n    return values\n}\n\nloadImage.parseExifTag = function (dataView, tiffOffset, offset, littleEndian, data) {\n    var tag = dataView.getUint16(offset, littleEndian)\n    data.exif[tag] = loadImage.getExifValue(\n        dataView,\n        tiffOffset,\n        offset,\n        dataView.getUint16(offset + 2, littleEndian), // tag type\n        dataView.getUint32(offset + 4, littleEndian), // tag length\n        littleEndian\n    )\n}\n\nloadImage.parseExifTags = function (dataView, tiffOffset, dirOffset, littleEndian, data) {\n    var tagsNumber,\n        dirEndOffset,\n        i\n    if (dirOffset + 6 > dataView.byteLength) {\n        console.log('Invalid Exif data: Invalid directory offset.')\n        return\n    }\n    tagsNumber = dataView.getUint16(dirOffset, littleEndian)\n    dirEndOffset = dirOffset + 2 + 12 * tagsNumber\n    if (dirEndOffset + 4 > dataView.byteLength) {\n        console.log('Invalid Exif data: Invalid directory size.')\n        return\n    }\n    for (i = 0; i < tagsNumber; i += 1) {\n        this.parseExifTag(\n            dataView,\n            tiffOffset,\n            dirOffset + 2 + 12 * i, // tag offset\n            littleEndian,\n            data\n        )\n    }\n    // Return the offset to the next directory:\n    return dataView.getUint32(dirEndOffset, littleEndian)\n}\n\nloadImage.parseExifData = function (dataView, offset, length, data, options) {\n    if (options.disableExif) {\n        return\n    }\n    var tiffOffset = offset + 10\n    var littleEndian\n    var dirOffset\n    var thumbnailData\n    // Check for the ASCII code for \"Exif\" (0x45786966):\n    if (dataView.getUint32(offset + 4) !== 0x45786966) {\n        // No Exif data, might be XMP data instead\n        return\n    }\n    if (tiffOffset + 8 > dataView.byteLength) {\n        console.log('Invalid Exif data: Invalid segment size.')\n        return\n    }\n    // Check for the two null bytes:\n    if (dataView.getUint16(offset + 8) !== 0x0000) {\n        console.log('Invalid Exif data: Missing byte alignment offset.')\n        return\n    }\n    // Check the byte alignment:\n    switch (dataView.getUint16(tiffOffset)) {\n        case 0x4949:\n            littleEndian = true\n            break\n        case 0x4D4D:\n            littleEndian = false\n            break\n        default:\n            console.log('Invalid Exif data: Invalid byte alignment marker.')\n            return\n    }\n    // Check for the TIFF tag marker (0x002A):\n    if (dataView.getUint16(tiffOffset + 2, littleEndian) !== 0x002A) {\n        console.log('Invalid Exif data: Missing TIFF marker.')\n        return\n    }\n    // Retrieve the directory offset bytes, usually 0x00000008 or 8 decimal:\n    dirOffset = dataView.getUint32(tiffOffset + 4, littleEndian)\n    // Create the exif object to store the tags:\n    data.exif = new loadImage.ExifMap()\n    // Parse the tags of the main image directory and retrieve the\n    // offset to the next directory, usually the thumbnail directory:\n    dirOffset = loadImage.parseExifTags(\n        dataView,\n        tiffOffset,\n        tiffOffset + dirOffset,\n        littleEndian,\n        data\n    )\n    if (dirOffset && !options.disableExifThumbnail) {\n        thumbnailData = {exif: {}}\n        dirOffset = loadImage.parseExifTags(\n            dataView,\n            tiffOffset,\n            tiffOffset + dirOffset,\n            littleEndian,\n            thumbnailData\n        )\n        // Check for JPEG Thumbnail offset:\n        if (thumbnailData.exif[0x0201]) {\n            data.exif.Thumbnail = loadImage.getExifThumbnail(\n                dataView,\n                tiffOffset + thumbnailData.exif[0x0201],\n                thumbnailData.exif[0x0202] // Thumbnail data length\n            )\n        }\n    }\n    // Check for Exif Sub IFD Pointer:\n    if (data.exif[0x8769] && !options.disableExifSub) {\n        loadImage.parseExifTags(\n            dataView,\n            tiffOffset,\n            tiffOffset + data.exif[0x8769], // directory offset\n            littleEndian,\n            data\n        )\n    }\n    // Check for GPS Info IFD Pointer:\n    if (data.exif[0x8825] && !options.disableExifGps) {\n        loadImage.parseExifTags(\n            dataView,\n            tiffOffset,\n            tiffOffset + data.exif[0x8825], // directory offset\n            littleEndian,\n            data\n        )\n    }\n}\n\n// Registers the Exif parser for the APP1 JPEG meta data segment:\nloadImage.metaDataParsers.jpeg[0xffe1].push(loadImage.parseExifData)\n\nvar snabbt = (function() {\n\n  var tickRequests = [];\n  var runningAnimations = [];\n  var completedAnimations = [];\n  var transformProperty = 'transform';\n\n  // Find which vendor prefix to use\n  var styles = window.getComputedStyle(document.documentElement, '');\n  var vendorPrefix = (Array.prototype.slice\n      .call(styles)\n      .join('') \n      .match(/-(moz|webkit|ms)-/) || (styles.OLink === '' && ['', 'o'])\n    )[1];\n  if(vendorPrefix === 'webkit')\n    transformProperty = 'webkitTransform';\n\n  /* Entry point, only function to be called by user */\n  var snabbt = function(arg1, arg2, arg3) {\n\n    var elements = arg1;\n\n    // If argument is an Array or a NodeList or other list type that can be iterable.\n    // Loop through and start one animation for each element.\n    if(elements.length !== undefined) {\n      var aggregateChainer = {\n        chainers: [],\n        then: function(opts) {\n          return this.snabbt(opts);\n        },\n        snabbt: function(opts) {\n          var len = this.chainers.length;\n          this.chainers.forEach(function(chainer, index) {\n            chainer.snabbt(preprocessOptions(opts, index, len));\n          });\n          return aggregateChainer;\n        },\n        setValue: function(value) {\n          this.chainers.forEach(function(chainer) {\n            chainer.setValue(value);\n          });\n          return aggregateChainer;\n        },\n        finish: function() {\n          this.chainers.forEach(function(chainer) {\n            chainer.finish();\n          });\n          return aggregateChainer;\n        },\n        rollback: function() {\n          this.chainers.forEach(function(chainer) {\n            chainer.rollback();\n          });\n          return aggregateChainer;\n        }\n      };\n\n      for(var i=0, len=elements.length;i<len;++i) {\n        if(typeof arg2 == 'string')\n          aggregateChainer.chainers.push(snabbtSingleElement(elements[i], arg2, preprocessOptions(arg3, i, len)));\n        else\n          aggregateChainer.chainers.push(snabbtSingleElement(elements[i], preprocessOptions(arg2, i, len), arg3));\n      }\n      return aggregateChainer;\n    } else {\n      if(typeof arg2 == 'string')\n        return snabbtSingleElement(elements, arg2, preprocessOptions(arg3, 0, 1));\n      else\n        return snabbtSingleElement(elements, preprocessOptions(arg2, 0, 1), arg3);\n    }\n  };\n\n  var preprocessOptions = function(options, index, len) {\n    if(!options)\n      return options;\n    var clone = cloneObject(options);\n\n    if(isFunction(options.delay)) {\n      clone.delay = options.delay(index, len);\n    }\n\n    if(isFunction(options.callback)) {\n      clone.complete = function() {\n        options.callback.call(this, index, len);\n      };\n    }\n\n    var hasAllDoneCallback = isFunction(options.allDone);\n    var hasCompleteCallback = isFunction(options.complete);\n\n    if(hasCompleteCallback || hasAllDoneCallback) {\n      clone.complete = function() {\n        if(hasCompleteCallback) {\n          options.complete.call(this, index, len);\n        }\n        if(hasAllDoneCallback && (index == len - 1)) {\n          options.allDone();\n        }\n      };\n    }\n\n    if(isFunction(options.valueFeeder)) {\n      clone.valueFeeder = function(i, matrix) {\n        return options.valueFeeder(i, matrix, index, len);\n      };\n    }\n    if(isFunction(options.easing)) {\n      clone.easing = function(i) {\n        return options.easing(i, index, len);\n      };\n    }\n\n    var properties = [\n      'position',\n      'rotation',\n      'skew',\n      'rotationPost',\n      'scale',\n      'width',\n      'height',\n      'opacity',\n      'fromPosition',\n      'fromRotation',\n      'fromSkew',\n      'fromRotationPost',\n      'fromScale',\n      'fromWidth',\n      'fromHeight',\n      'fromOpacity',\n      'transformOrigin',\n      'duration',\n      'delay'\n    ];\n\n    properties.forEach(function(property) {\n      if(isFunction(options[property])) {\n        clone[property] = options[property](index, len);\n      }\n    });\n\n    return clone;\n  };\n\n  var snabbtSingleElement = function(element, arg2, arg3) {\n    if(arg2 === 'attention')\n      return setupAttentionAnimation(element, arg3);\n    if(arg2 === 'stop')\n      return stopAnimation(element);\n    var options = arg2;\n\n    // Remove orphaned end states\n    clearOphanedEndStates();\n\n    // If there is a running or past completed animation with element, use that end state as start state\n    var currentState = currentAnimationState(element);\n    var start = currentState;\n    // from has precendance over current animation state\n    start = stateFromOptions(options, start, true);\n    var end = cloneObject(currentState);\n    end = stateFromOptions(options, end);\n\n    var animOptions = setupAnimationOptions(start, end, options);\n    var animation = createAnimation(animOptions);\n\n    runningAnimations.push([element, animation]);\n\n    animation.updateElement(element, true);\n    var queue = [];\n    var chainer = {\n      snabbt: function(opts) {\n        queue.unshift(preprocessOptions(opts, 0, 1));\n        return chainer;\n      },\n      then: function(opts) {\n        return this.snabbt(opts);\n      }\n    };\n\n    function tick(time) {\n      animation.tick(time);\n      animation.updateElement(element);\n      if(animation.isStopped())\n        return;\n\n      if(!animation.completed())\n        return queueTick(tick);\n\n      if(options.loop > 1 && !animation.isStopped()) {\n        // Loop current animation\n        options.loop -= 1;\n        animation.restart();\n        queueTick(tick);\n      } else {\n        if(options.complete) {\n          options.complete.call(element);\n        }\n\n        // Start next animation in queue\n        if(queue.length) {\n          options = queue.pop();\n\n          start = stateFromOptions(options, end, true);\n          end = stateFromOptions(options, cloneObject(end));\n          options = setupAnimationOptions(start, end, options);\n\n          animation = createAnimation(options);\n          runningAnimations.push([element, animation]);\n\n          animation.tick(time);\n          queueTick(tick);\n        }\n      }\n    }\n\n    queueTick(tick);\n    // Manual animations are not chainable, instead an animation controller object is returned\n    // with setValue, finish and rollback methods\n    if(options.manual)\n      return animation;\n    return chainer;\n  };\n\n  var setupAttentionAnimation = function(element,  options) {\n    var movement = stateFromOptions(options, createState({}));\n    options.movement = movement;\n    var animation = createAttentionAnimation(options);\n\n    runningAnimations.push([element, animation]);\n    function tick(time) {\n      animation.tick(time);\n      animation.updateElement(element);\n      if(!animation.completed()) {\n        queueTick(tick);\n      } else {\n        if(options.callback) {\n          options.callback(element);\n        }\n        if(options.loop && options.loop > 1) {\n          options.loop--;\n          animation.restart();\n          queueTick(tick);\n        }\n      }\n    }\n    queueTick(tick);\n  };\n\n  var stopAnimation = function(element) {\n    for(var i= 0,len=runningAnimations.length;i<len;++i) {\n      var currentAnimation = runningAnimations[i];\n      var animatedElement = currentAnimation[0];\n      var animation = currentAnimation[1];\n\n      if(animatedElement === element) {\n        animation.stop();\n      }\n    }\n  };\n\n  var findAnimationState = function(animationList, element) {\n    for(var i=0,len=animationList.length;i<len;++i) {\n      var currentAnimation = animationList[i];\n      var animatedElement = currentAnimation[0];\n      var animation = currentAnimation[1];\n\n      if(animatedElement === element) {\n        var state = animation.getCurrentState();\n        animation.stop();\n        return state;\n      }\n    }\n  };\n\n  var clearOphanedEndStates = function() {\n    completedAnimations = completedAnimations.filter(function(animation) {\n      return (findUltimateAncestor(animation[0]).body);\n    });\n  };\n\n  var findUltimateAncestor = function(node) {\n    var ancestor = node;\n    while(ancestor.parentNode) {\n      ancestor = ancestor.parentNode;\n    }\n    return ancestor;\n  };\n\n  /**\n   * Returns the current state of element if there is an ongoing or previously finished\n   * animation releated to it. Will also call stop on the animation.\n   * TODO: The stopping of the animation is better put somewhere else\n   */\n  var currentAnimationState = function(element) {\n    // Check if a completed animation is stored for this element\n    var state = findAnimationState(runningAnimations, element);\n    if(state)\n      return state;\n   \n    return findAnimationState(completedAnimations, element);\n  };\n\n  /**\n   * Parses an animation configuration object and returns a State instance\n   */\n  var stateFromOptions = function(options, state, useFromPrefix) {\n    if (!state) {\n      state = createState({\n        position: [0, 0, 0],\n        rotation: [0, 0, 0],\n        rotationPost: [0, 0, 0],\n        scale: [1, 1],\n        skew: [0, 0]\n      });\n    }\n    var position = 'position';\n    var rotation = 'rotation';\n    var skew = 'skew';\n    var rotationPost = 'rotationPost';\n    var scale = 'scale';\n    var scalePost = 'scalePost';\n    var width = 'width';\n    var height = 'height';\n    var opacity = 'opacity';\n\n    if(useFromPrefix) {\n      position = 'fromPosition';\n      rotation = 'fromRotation';\n      skew = 'fromSkew';\n      rotationPost = 'fromRotationPost';\n      scale = 'fromScale';\n      scalePost = 'fromScalePost';\n      width = 'fromWidth';\n      height = 'fromHeight';\n      opacity = 'fromOpacity';\n    }\n\n    state.position = optionOrDefault(options[position], state.position);\n    state.rotation = optionOrDefault(options[rotation], state.rotation);\n    state.rotationPost = optionOrDefault(options[rotationPost], state.rotationPost);\n    state.skew = optionOrDefault(options[skew], state.skew);\n    state.scale = optionOrDefault(options[scale], state.scale);\n    state.scalePost = optionOrDefault(options[scalePost], state.scalePost);\n    state.opacity = options[opacity];\n    state.width = options[width];\n    state.height = options[height];\n\n    return state;\n  };\n\n  var setupAnimationOptions = function(start, end, options) {\n    options.startState = start;\n    options.endState = end;\n    return options;\n  };\n\n  var polyFillrAF = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) { return setTimeout(callback, 1000 / 60); }; \n\n  var queueTick = function(func) {\n    if(tickRequests.length === 0)\n      polyFillrAF(tickAnimations);\n    tickRequests.push(func);\n  };\n\n  var tickAnimations = function(time) {\n    var len = tickRequests.length;\n    for(var i=0;i<len;++i) {\n      tickRequests[i](time);\n    }\n    tickRequests.splice(0, len);\n\n    var finishedAnimations = runningAnimations.filter(function(animation) {\n      return animation[1].completed();\n    });\n\n    // See if there are any previously completed animations on the same element, if so, remove it before merging\n    completedAnimations = completedAnimations.filter(function(animation) {\n      for(var i=0,len=finishedAnimations.length;i<len;++i) {\n        if(animation[0] === finishedAnimations[i][0]) {\n          return false;\n        }\n      }\n      return true;\n    });\n\n    completedAnimations = completedAnimations.concat(finishedAnimations);\n\n    runningAnimations = runningAnimations.filter(function(animation) {\n      return !animation[1].completed();\n    });\n\n    if(tickRequests.length !== 0)\n      polyFillrAF(tickAnimations);\n  };\n\n\n  // Class for handling animation between two states\n  var createAnimation = function(options) {\n    var startState = options.startState;\n    var endState = options.endState;\n    var duration = optionOrDefault(options.duration, 500);\n    var delay = optionOrDefault(options.delay, 0);\n    var perspective = options.perspective;\n    var easing = createEaser(optionOrDefault(options.easing, 'linear'), options);\n    var currentState = duration === 0 ? endState.clone() : startState.clone();\n    var transformOrigin = options.transformOrigin;\n    currentState.transformOrigin = options.transformOrigin;\n\n    var startTime = 0;\n    var currentTime = 0;\n    var stopped = false;\n    var started = false;\n\n    // Manual related\n    var manual = options.manual;\n    var manualValue = 0;\n    var manualDelayFactor = delay / duration;\n    var manualCallback;\n\n    var tweener;\n    // Setup tweener\n    if(options.valueFeeder) {\n      tweener = createValueFeederTweener(options.valueFeeder,\n                                         startState,\n                                         endState,\n                                         currentState);\n    } else {\n      tweener = createStateTweener(startState, endState, currentState);\n    }\n\n    // Public api\n    return {\n      stop: function() {\n        stopped = true;\n      },\n      isStopped: function() {\n        return stopped;\n      },\n\n      finish: function(callback) {\n        manual = false;\n        var manualDuration = duration * manualValue;\n        startTime = currentTime - manualDuration;\n        manualCallback = callback;\n        easing.resetFrom = manualValue;\n      },\n\n      rollback: function(callback) {\n        manual = false;\n        tweener.setReverse();\n        var manualDuration = duration * (1 - manualValue);\n        startTime = currentTime - manualDuration;\n        manualCallback = callback;\n        easing.resetFrom = manualValue;\n      },\n\n      restart: function() {\n        // Restart timer\n        startTime = undefined;\n        easing.resetFrom(0);\n      },\n\n      tick: function(time) {\n        if(stopped)\n          return;\n\n        if(manual) {\n          currentTime = time;\n          this.updateCurrentTransform();\n          return;\n        }\n\n        // If first tick, set startTime\n        if(!startTime) {\n          startTime = time;\n        }\n        if(time - startTime > delay) {\n          started = true;\n          currentTime = time - delay;\n\n          var curr = Math.min(Math.max(0.0, currentTime - startTime), duration);\n          easing.tick(curr / duration);\n          this.updateCurrentTransform();\n          if(this.completed() && manualCallback) {\n            manualCallback();\n          }\n        }\n      },\n\n      getCurrentState: function() {\n        return currentState;\n      },\n\n      setValue: function(_manualValue) {\n        started = true;\n        manualValue = Math.min(Math.max(_manualValue, 0.0001), 1 + manualDelayFactor);\n      },\n\n      updateCurrentTransform: function() {\n        var tweenValue = easing.getValue();\n        if(manual) {\n          var val = Math.max(0.00001, manualValue - manualDelayFactor);\n          easing.tick(val);\n          tweenValue = easing.getValue();\n        }\n        tweener.tween(tweenValue);\n      },\n\n      completed: function() {\n        if(stopped)\n          return true;\n        if(startTime === 0) {\n          return false;\n        }\n        return easing.completed();\n      },\n\n      updateElement: function(element, forceUpdate) {\n        if(!started && !forceUpdate)\n          return;\n        var matrix = tweener.asMatrix();\n        var properties = tweener.getProperties();\n        updateElementTransform(element, matrix, perspective);\n        updateElementProperties(element, properties);\n      }\n    };\n  };\n\n  // ------------------------------\n  // End Time animation\n  // ------------------------------\n\n  // ------------------------\n  // -- AttentionAnimation --\n  // ------------------------\n\n  var createAttentionAnimation = function(options) {\n    var movement = options.movement;\n    options.initialVelocity = 0.1;\n    options.equilibriumPosition = 0;\n    var spring = createSpringEasing(options);\n    var stopped = false;\n    var tweenPosition = movement.position;\n    var tweenRotation = movement.rotation;\n    var tweenRotationPost = movement.rotationPost;\n    var tweenScale = movement.scale;\n    var tweenSkew = movement.skew;\n\n    var currentMovement = createState({\n      position: tweenPosition ? [0, 0, 0] : undefined,\n      rotation: tweenRotation ? [0, 0, 0] : undefined,\n      rotationPost: tweenRotationPost ? [0, 0, 0] : undefined,\n      scale: tweenScale ? [0, 0] : undefined,\n      skew: tweenSkew ? [0, 0] : undefined,\n    });\n\n    // Public API\n    return {\n      stop: function() {\n        stopped = true;\n      },\n\n      isStopped: function(time) {\n        return stopped;\n      },\n\n      tick: function(time) {\n        if(stopped)\n          return;\n        if(spring.equilibrium)\n          return;\n        spring.tick();\n\n        this.updateMovement();\n      },\n\n      updateMovement:function() {\n        var value = spring.getValue();\n        if(tweenPosition) {\n          currentMovement.position[0] = movement.position[0] * value;\n          currentMovement.position[1] = movement.position[1] * value;\n          currentMovement.position[2] = movement.position[2] * value;\n        }\n        if(tweenRotation) {\n          currentMovement.rotation[0] = movement.rotation[0] * value;\n          currentMovement.rotation[1] = movement.rotation[1] * value;\n          currentMovement.rotation[2] = movement.rotation[2] * value;\n        }\n        if(tweenRotationPost) {\n          currentMovement.rotationPost[0] = movement.rotationPost[0] * value;\n          currentMovement.rotationPost[1] = movement.rotationPost[1] * value;\n          currentMovement.rotationPost[2] = movement.rotationPost[2] * value;\n        }\n        if(tweenScale) {\n          currentMovement.scale[0] = 1 + movement.scale[0] * value;\n          currentMovement.scale[1] = 1 + movement.scale[1] * value;\n        }\n\n        if(tweenSkew) {\n          currentMovement.skew[0] = movement.skew[0] * value;\n          currentMovement.skew[1] = movement.skew[1] * value;\n        }\n      },\n\n      updateElement: function(element) {\n        updateElementTransform(element, currentMovement.asMatrix());\n        updateElementProperties(element, currentMovement.getProperties());\n      },\n\n      getCurrentState: function() {\n        return currentMovement;\n      },\n\n      completed: function() {\n        return spring.equilibrium || stopped;\n      },\n\n      restart: function() {\n        // Restart spring\n        spring = createSpringEasing(options);\n      }\n    };\n  };\n\n\n  /**********\n  * Easings *\n  ***********/\n\n  var linearEasing = function(value) {\n    return value;\n  };\n\n  var ease = function(value) {\n    return (Math.cos(value*Math.PI + Math.PI) + 1)/2;\n  };\n\n  var easeIn = function(value) {\n    return value*value;\n  };\n\n  var easeOut = function(value) {\n    return -Math.pow(value - 1, 2) + 1;\n  };\n\n  var createSpringEasing = function(options) {\n    var position = optionOrDefault(options.startPosition, 0);\n    var equilibriumPosition = optionOrDefault(options.equilibriumPosition, 1);\n    var velocity = optionOrDefault(options.initialVelocity, 0);\n    var springConstant = optionOrDefault(options.springConstant, 0.8);\n    var deceleration = optionOrDefault(options.springDeceleration, 0.9);\n    var mass = optionOrDefault(options.springMass, 10);\n\n    var equilibrium = false;\n\n    // Public API\n    return {\n\n      tick: function(value) {\n        if(value === 0.0)\n          return;\n        if(equilibrium)\n          return;\n        var springForce = -(position - equilibriumPosition) * springConstant;\n        // f = m * a\n        // a = f / m\n        var a = springForce / mass;\n        // s = v * t\n        // t = 1 ( for now )\n        velocity += a;\n        position += velocity;\n\n        // Deceleration\n        velocity *= deceleration;\n\n        if(Math.abs(position - equilibriumPosition) < 0.001 && Math.abs(velocity) < 0.001) {\n          equilibrium = true;\n        }\n      },\n\n      resetFrom: function(value) {\n        position = value;\n        velocity = 0;\n      },\n\n\n      getValue: function() {\n        if(equilibrium)\n          return equilibriumPosition;\n        return position;\n      },\n\n      completed: function() {\n        return equilibrium;\n      }\n    };\n  };\n\n  var EASING_FUNCS = {\n    'linear': linearEasing,\n    'ease': ease,\n    'easeIn': easeIn,\n    'easeOut': easeOut,\n  };\n\n\n  var createEaser = function(easerName, options) {\n    if(easerName == 'spring') {\n      return createSpringEasing(options);\n    }\n    var easeFunction = easerName;\n    if(!isFunction(easerName)) {\n      easeFunction = EASING_FUNCS[easerName];\n    }\n\n    var easer = easeFunction;\n    var value = 0;\n    var lastValue;\n\n    // Public API\n    return {\n      tick: function(v) {\n        value = easer(v);\n        lastValue = v;\n      },\n\n      resetFrom: function(value) {\n        lastValue = 0;\n      },\n\n      getValue: function() {\n        return value;\n      },\n\n      completed: function() {\n        if(lastValue >= 1) {\n          return lastValue;\n        }\n        return false;\n      }\n    };\n  };\n\n  /***\n   * Matrix related\n   */\n\n  var assignTranslate = function(matrix, x, y, z) {\n    matrix[0] = 1;\n    matrix[1] = 0;\n    matrix[2] = 0;\n    matrix[3] = 0;\n    matrix[4] = 0;\n    matrix[5] = 1;\n    matrix[6] = 0;\n    matrix[7] = 0;\n    matrix[8] = 0;\n    matrix[9] = 0;\n    matrix[10] = 1;\n    matrix[11] = 0;\n    matrix[12] = x;\n    matrix[13] = y;\n    matrix[14] = z;\n    matrix[15] = 1;\n  };\n\n  var assignRotateX = function(matrix, rad) {\n    matrix[0] = 1;\n    matrix[1] = 0;\n    matrix[2] = 0;\n    matrix[3] = 0;\n    matrix[4] = 0;\n    matrix[5] = Math.cos(rad);\n    matrix[6] = -Math.sin(rad);\n    matrix[7] = 0;\n    matrix[8] = 0;\n    matrix[9] = Math.sin(rad);\n    matrix[10] = Math.cos(rad);\n    matrix[11] = 0;\n    matrix[12] = 0;\n    matrix[13] = 0;\n    matrix[14] = 0;\n    matrix[15] = 1;\n  };\n\n\n  var assignRotateY = function(matrix, rad) {\n    matrix[0] = Math.cos(rad);\n    matrix[1] = 0;\n    matrix[2] = Math.sin(rad);\n    matrix[3] = 0;\n    matrix[4] = 0;\n    matrix[5] = 1;\n    matrix[6] = 0;\n    matrix[7] = 0;\n    matrix[8] = -Math.sin(rad);\n    matrix[9] = 0;\n    matrix[10] = Math.cos(rad);\n    matrix[11] = 0;\n    matrix[12] = 0;\n    matrix[13] = 0;\n    matrix[14] = 0;\n    matrix[15] = 1;\n  };\n\n  var assignRotateZ = function(matrix, rad) {\n    matrix[0] = Math.cos(rad);\n    matrix[1] = -Math.sin(rad);\n    matrix[2] = 0;\n    matrix[3] = 0;\n    matrix[4] = Math.sin(rad);\n    matrix[5] = Math.cos(rad);\n    matrix[6] = 0;\n    matrix[7] = 0;\n    matrix[8] = 0;\n    matrix[9] = 0;\n    matrix[10] = 1;\n    matrix[11] = 0;\n    matrix[12] = 0;\n    matrix[13] = 0;\n    matrix[14] = 0;\n    matrix[15] = 1;\n  };\n\n  var assignSkew = function(matrix, ax, ay) {\n    matrix[0] = 1;\n    matrix[1] = Math.tan(ax);\n    matrix[2] = 0;\n    matrix[3] = 0;\n    matrix[4] = Math.tan(ay);\n    matrix[5] = 1;\n    matrix[6] = 0;\n    matrix[7] = 0;\n    matrix[8] = 0;\n    matrix[9] = 0;\n    matrix[10] = 1;\n    matrix[11] = 0;\n    matrix[12] = 0;\n    matrix[13] = 0;\n    matrix[14] = 0;\n    matrix[15] = 1;\n  };\n\n\n  var assignScale = function(matrix, x, y) {\n    matrix[0] = x;\n    matrix[1] = 0;\n    matrix[2] = 0;\n    matrix[3] = 0;\n    matrix[4] = 0;\n    matrix[5] = y;\n    matrix[6] = 0;\n    matrix[7] = 0;\n    matrix[8] = 0;\n    matrix[9] = 0;\n    matrix[10] = 1;\n    matrix[11] = 0;\n    matrix[12] = 0;\n    matrix[13] = 0;\n    matrix[14] = 0;\n    matrix[15] = 1;\n  };\n\n  var assignIdentity = function(matrix) {\n    matrix[0] = 1;\n    matrix[1] = 0;\n    matrix[2] = 0;\n    matrix[3] = 0;\n    matrix[4] = 0;\n    matrix[5] = 1;\n    matrix[6] = 0;\n    matrix[7] = 0;\n    matrix[8] = 0;\n    matrix[9] = 0;\n    matrix[10] = 1;\n    matrix[11] = 0;\n    matrix[12] = 0;\n    matrix[13] = 0;\n    matrix[14] = 0;\n    matrix[15] = 1;\n  };\n\n  var copyArray = function(a, b) {\n    b[0] = a[0];\n    b[1] = a[1];\n    b[2] = a[2];\n    b[3] = a[3];\n    b[4] = a[4];\n    b[5] = a[5];\n    b[6] = a[6];\n    b[7] = a[7];\n    b[8] = a[8];\n    b[9] = a[9];\n    b[10] = a[10];\n    b[11] = a[11];\n    b[12] = a[12];\n    b[13] = a[13];\n    b[14] = a[14];\n    b[15] = a[15];\n  };\n\n  var createMatrix = function() {\n    var data = new Float32Array(16);\n    var a = new Float32Array(16);\n    var b = new Float32Array(16);\n    assignIdentity(data);\n\n    return {\n      data: data,\n\n      asCSS: function() {\n        var css = 'matrix3d(';\n        for(var i=0;i<15;++i) {\n          if(Math.abs(data[i]) < 0.0001)\n            css += '0,';\n          else\n            css += data[i].toFixed(10) + ',';\n        }\n        if(Math.abs(data[15]) < 0.0001)\n          css += '0)';\n        else\n          css += data[15].toFixed(10) + ')';\n        return css;\n      },\n\n      clear: function() {\n        assignIdentity(data);\n      },\n\n      translate: function(x, y, z) {\n        copyArray(data, a);\n        assignTranslate(b, x, y, z);\n        assignedMatrixMultiplication(a, b, data);\n        return this;\n      },\n\n      rotateX: function(radians) {\n        copyArray(data, a);\n        assignRotateX(b, radians);\n        assignedMatrixMultiplication(a, b, data);\n        return this;\n      },\n\n      rotateY: function(radians) {\n        copyArray(data, a);\n        assignRotateY(b, radians);\n        assignedMatrixMultiplication(a, b, data);\n        return this;\n      },\n\n      rotateZ: function(radians) {\n        copyArray(data, a);\n        assignRotateZ(b, radians);\n        assignedMatrixMultiplication(a, b, data);\n        return this;\n      },\n\n      scale: function(x, y) {\n        copyArray(data, a);\n        assignScale(b, x, y);\n        assignedMatrixMultiplication(a, b, data);\n        return this;\n      },\n\n      skew: function(ax, ay) {\n        copyArray(data, a);\n        assignSkew(b, ax, ay);\n        assignedMatrixMultiplication(a, b, data);\n        return this;\n      }\n    };\n  };\n\n  var assignedMatrixMultiplication = function(a, b, res) {\n    // Unrolled loop\n    res[0] = a[0] * b[0] + a[1] * b[4] + a[2] * b[8] + a[3] * b[12];\n    res[1] = a[0] * b[1] + a[1] * b[5] + a[2] * b[9] + a[3] * b[13];\n    res[2] = a[0] * b[2] + a[1] * b[6] + a[2] * b[10] + a[3] * b[14];\n    res[3] = a[0] * b[3] + a[1] * b[7] + a[2] * b[11] + a[3] * b[15];\n\n    res[4] = a[4] * b[0] + a[5] * b[4] + a[6] * b[8] + a[7] * b[12];\n    res[5] = a[4] * b[1] + a[5] * b[5] + a[6] * b[9] + a[7] * b[13];\n    res[6] = a[4] * b[2] + a[5] * b[6] + a[6] * b[10] + a[7] * b[14];\n    res[7] = a[4] * b[3] + a[5] * b[7] + a[6] * b[11] + a[7] * b[15];\n\n    res[8] = a[8] * b[0] + a[9] * b[4] + a[10] * b[8] + a[11] * b[12];\n    res[9] = a[8] * b[1] + a[9] * b[5] + a[10] * b[9] + a[11] * b[13];\n    res[10] = a[8] * b[2] + a[9] * b[6] + a[10] * b[10] + a[11] * b[14];\n    res[11] = a[8] * b[3] + a[9] * b[7] + a[10] * b[11] + a[11] * b[15];\n\n    res[12] = a[12] * b[0] + a[13] * b[4] + a[14] * b[8] + a[15] * b[12];\n    res[13] = a[12] * b[1] + a[13] * b[5] + a[14] * b[9] + a[15] * b[13];\n    res[14] = a[12] * b[2] + a[13] * b[6] + a[14] * b[10] + a[15] * b[14];\n    res[15] = a[12] * b[3] + a[13] * b[7] + a[14] * b[11] + a[15] * b[15];\n\n    return res;\n  };\n\n  var createState = function(config) {\n    // Caching of matrix and properties so we don't have to create new ones everytime they are needed\n    var matrix = createMatrix();\n    var properties = {\n      opacity: undefined,\n      width: undefined,\n      height: undefined\n    };\n\n    // Public API\n    return {\n      position: config.position,\n      rotation: config.rotation,\n      rotationPost: config.rotationPost,\n      skew: config.skew,\n      scale: config.scale,\n      scalePost: config.scalePost,\n      opacity: config.opacity,\n      width: config.width,\n      height: config.height,\n\n\n      clone: function() {\n        return createState({\n          position: this.position ? this.position.slice(0) : undefined,\n          rotation: this.rotation ? this.rotation.slice(0) : undefined,\n          rotationPost: this.rotationPost ? this.rotationPost.slice(0) : undefined,\n          skew: this.skew ? this.skew.slice(0) : undefined,\n          scale: this.scale ? this.scale.slice(0) : undefined,\n          scalePost: this.scalePost ? this.scalePost.slice(0) : undefined,\n          height: this.height,\n          width: this.width,\n          opacity: this.opacity\n        });\n      },\n\n      asMatrix: function() {\n        var m = matrix;\n        m.clear();\n\n        if(this.transformOrigin)\n          m.translate(-this.transformOrigin[0], -this.transformOrigin[1], -this.transformOrigin[2]);\n\n        if(this.scale) {\n          m.scale(this.scale[0], this.scale[1]);\n        }\n\n        if(this.skew) {\n          m.skew(this.skew[0], this.skew[1]);\n        }\n\n        if(this.rotation) {\n          m.rotateX(this.rotation[0]);\n          m.rotateY(this.rotation[1]);\n          m.rotateZ(this.rotation[2]);\n        }\n\n        if(this.position) {\n          m.translate(this.position[0], this.position[1], this.position[2]);\n        }\n\n        if(this.rotationPost) {\n          m.rotateX(this.rotationPost[0]);\n          m.rotateY(this.rotationPost[1]);\n          m.rotateZ(this.rotationPost[2]);\n        }\n\n        if(this.scalePost) {\n          m.scale(this.scalePost[0], this.scalePost[1]);\n        }\n\n        if(this.transformOrigin)\n          m.translate(this.transformOrigin[0], this.transformOrigin[1], this.transformOrigin[2]);\n        return m;\n      },\n\n      getProperties: function() {\n        properties.opacity = this.opacity;\n        properties.width = this.width + 'px';\n        properties.height = this.height + 'px';\n        return properties;\n      }\n    };\n  };\n  // ------------------\n  // -- StateTweener -- \n  // -------------------\n\n  var createStateTweener = function(startState, endState, resultState) {\n    var start = startState;\n    var end = endState;\n    var result = resultState;\n    \n    var tweenPosition = end.position !== undefined;\n    var tweenRotation = end.rotation !== undefined;\n    var tweenRotationPost = end.rotationPost !== undefined;\n    var tweenScale = end.scale !== undefined;\n    var tweenSkew = end.skew !== undefined;\n    var tweenWidth = end.width !== undefined;\n    var tweenHeight = end.height !== undefined;\n    var tweenOpacity = end.opacity !== undefined;\n\n    // Public API\n    return {\n\n      tween: function(tweenValue) {\n\n        if(tweenPosition) {\n          var dX = (end.position[0] - start.position[0]);\n          var dY = (end.position[1] - start.position[1]);\n          var dZ = (end.position[2] - start.position[2]);\n          result.position[0] = start.position[0] + tweenValue*dX;\n          result.position[1] = start.position[1] + tweenValue*dY;\n          result.position[2] = start.position[2] + tweenValue*dZ;\n        }\n\n        if(tweenRotation) {\n          var dAX = (end.rotation[0] - start.rotation[0]);\n          var dAY = (end.rotation[1] - start.rotation[1]);\n          var dAZ = (end.rotation[2] - start.rotation[2]);\n          result.rotation[0] = start.rotation[0] + tweenValue*dAX;\n          result.rotation[1] = start.rotation[1] + tweenValue*dAY;\n          result.rotation[2] = start.rotation[2] + tweenValue*dAZ;\n        }\n\n        if(tweenRotationPost) {\n          var dBX = (end.rotationPost[0] - start.rotationPost[0]);\n          var dBY = (end.rotationPost[1] - start.rotationPost[1]);\n          var dBZ = (end.rotationPost[2] - start.rotationPost[2]);\n          result.rotationPost[0] = start.rotationPost[0] + tweenValue*dBX;\n          result.rotationPost[1] = start.rotationPost[1] + tweenValue*dBY;\n          result.rotationPost[2] = start.rotationPost[2] + tweenValue*dBZ;\n        }\n\n        if(tweenSkew) {\n          var dSX = (end.scale[0] - start.scale[0]);\n          var dSY = (end.scale[1] - start.scale[1]);\n\n          result.scale[0] = start.scale[0] + tweenValue*dSX;\n          result.scale[1] = start.scale[1] + tweenValue*dSY;\n        }\n\n        if(tweenScale) {\n          var dSkewX = (end.skew[0] - start.skew[0]);\n          var dSkewY = (end.skew[1] - start.skew[1]);\n\n          result.skew[0] = start.skew[0] + tweenValue*dSkewX;\n          result.skew[1] = start.skew[1] + tweenValue*dSkewY;\n        }\n\n        if(tweenWidth) {\n          var dWidth = (end.width - start.width);\n          result.width = start.width + tweenValue*dWidth;\n        }\n\n\n        if(tweenHeight) {\n          var dHeight = (end.height - start.height);\n          result.height = start.height + tweenValue*dHeight;\n        }\n\n        if(tweenOpacity) {\n          var dOpacity = (end.opacity - start.opacity);\n          result.opacity = start.opacity + tweenValue*dOpacity;\n        }\n\n      },\n\n      asMatrix: function() {\n        return result.asMatrix();\n      },\n\n      getProperties: function() {\n        return result.getProperties();\n      },\n\n      setReverse: function() {\n        var oldStart = start;\n        start = end;\n        end = oldStart;\n      }\n    };\n  };\n\n  // ------------------------\n  // -- ValueFeederTweener -- \n  // ------------------------\n\n  var createValueFeederTweener = function(valueFeeder, startState, endState, resultState) {\n    var currentMatrix = valueFeeder(0, createMatrix());\n    var start = startState;\n    var end = endState;\n    var result = resultState;\n    var reverse = false;\n\n\n    // Public API\n    return {\n\n      tween: function(tweenValue) {\n        if(reverse)\n          tweenValue = 1 - tweenValue;\n        currentMatrix.clear();\n        currentMatrix = valueFeeder(tweenValue, currentMatrix);\n\n        var dWidth = (end.width - start.width);\n        var dHeight = (end.height - start.height);\n        var dOpacity = (end.opacity - start.opacity);\n\n        if(end.width !== undefined)\n          result.width = start.width + tweenValue*dWidth;\n        if(end.height !== undefined)\n          result.height = start.height + tweenValue*dHeight;\n        if(end.opacity !== undefined)\n          result.opacity = start.opacity + tweenValue*dOpacity;\n      },\n\n      asMatrix: function() {\n        return currentMatrix;\n      },\n\n      getProperties: function() {\n        return result.getProperties();\n      },\n\n      setReverse: function() {\n        reverse = true;\n      }\n\n    };\n  };\n\n  var optionOrDefault = function(option, def) {\n    if(typeof option == 'undefined') {\n      return def;\n    }\n    return option;\n  };\n\n  var updateElementTransform = function(element, matrix, perspective) {\n    var cssPerspective = '';\n    if(perspective) {\n      cssPerspective = 'perspective(' + perspective + 'px) ';\n    }\n    var cssMatrix = matrix.asCSS();\n    element.style[transformProperty] = cssPerspective + cssMatrix;\n  };\n\n  var updateElementProperties = function(element, properties) {\n    for(var key in properties) {\n      element.style[key] = properties[key];\n    }\n  };\n\n  var isFunction = function(object) {\n    return (typeof object === \"function\");\n  };\n\n  var cloneObject = function(object) {\n    if(!object)\n      return object;\n    var clone = {};\n    for(var key in object) {\n      clone[key] = object[key];\n    }\n    return clone;\n  };\n\n  snabbt.createMatrix = createMatrix;\n  snabbt.setElementTransform = updateElementTransform;\n  return snabbt;\n}());\nvar stackBlur = (function(){\n\n\tvar mul_table = [\n\t\t512,512,456,512,328,456,335,512,405,328,271,456,388,335,292,512,\n\t\t454,405,364,328,298,271,496,456,420,388,360,335,312,292,273,512,\n\t\t482,454,428,405,383,364,345,328,312,298,284,271,259,496,475,456,\n\t\t437,420,404,388,374,360,347,335,323,312,302,292,282,273,265,512,\n\t\t497,482,468,454,441,428,417,405,394,383,373,364,354,345,337,328,\n\t\t320,312,305,298,291,284,278,271,265,259,507,496,485,475,465,456,\n\t\t446,437,428,420,412,404,396,388,381,374,367,360,354,347,341,335,\n\t\t329,323,318,312,307,302,297,292,287,282,278,273,269,265,261,512,\n\t\t505,497,489,482,475,468,461,454,447,441,435,428,422,417,411,405,\n\t\t399,394,389,383,378,373,368,364,359,354,350,345,341,337,332,328,\n\t\t324,320,316,312,309,305,301,298,294,291,287,284,281,278,274,271,\n\t\t268,265,262,259,257,507,501,496,491,485,480,475,470,465,460,456,\n\t\t451,446,442,437,433,428,424,420,416,412,408,404,400,396,392,388,\n\t\t385,381,377,374,370,367,363,360,357,354,350,347,344,341,338,335,\n\t\t332,329,326,323,320,318,315,312,310,307,304,302,299,297,294,292,\n\t\t289,287,285,282,280,278,275,273,271,269,267,265,263,261,259];\n\n\n\tvar shg_table = [\n\t\t9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17,\n\t\t17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19,\n\t\t19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20,\n\t\t20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21,\n\t\t21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n\t\t21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22,\n\t\t22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n\t\t22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23,\n\t\t23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,\n\t\t23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,\n\t\t23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,\n\t\t23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n\t\t24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n\t\t24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n\t\t24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n\t\t24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24 ];\n\n\tfunction getImageDataFromCanvas(canvas, top_x, top_y, width, height)\n\t{\n\t\tif (typeof(canvas) == 'string')\n\t\t\tcanvas  = document.getElementById(canvas);\n\t\telse if (!canvas instanceof HTMLCanvasElement)\n\t\t\treturn;\n\n\t\tvar context = canvas.getContext('2d');\n\t\tvar imageData;\n\n\t\ttry {\n\t\t\ttry {\n\t\t\t\timageData = context.getImageData(top_x, top_y, width, height);\n\t\t\t} catch(e) {\n\t\t\t\tthrow new Error(\"unable to access local image data: \" + e);\n\t\t\t\treturn;\n\t\t\t}\n\t\t} catch(e) {\n\t\t\tthrow new Error(\"unable to access image data: \" + e);\n\t\t}\n\n\t\treturn imageData;\n\t}\n\n\tfunction processCanvasRGBA(canvas, top_x, top_y, width, height, radius)\n\t{\n\t\tif (isNaN(radius) || radius < 1) return;\n\t\tradius |= 0;\n\n\t\tvar imageData = getImageDataFromCanvas(canvas, top_x, top_y, width, height);\n\n\t\timageData = processImageDataRGBA(imageData, top_x, top_y, width, height, radius);\n\n\t\tcanvas.getContext('2d').putImageData(imageData, top_x, top_y);\n\t}\n\n\tfunction processImageDataRGBA(imageData, top_x, top_y, width, height, radius)\n\t{\n\t\tvar pixels = imageData.data;\n\n\t\tvar x, y, i, p, yp, yi, yw, r_sum, g_sum, b_sum, a_sum,\n\t\t\tr_out_sum, g_out_sum, b_out_sum, a_out_sum,\n\t\t\tr_in_sum, g_in_sum, b_in_sum, a_in_sum,\n\t\t\tpr, pg, pb, pa, rbs;\n\n\t\tvar div = radius + radius + 1;\n\t\tvar w4 = width << 2;\n\t\tvar widthMinus1  = width - 1;\n\t\tvar heightMinus1 = height - 1;\n\t\tvar radiusPlus1  = radius + 1;\n\t\tvar sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2;\n\n\t\tvar stackStart = new BlurStack();\n\t\tvar stack = stackStart;\n\t\tfor (i = 1; i < div; i++)\n\t\t{\n\t\t\tstack = stack.next = new BlurStack();\n\t\t\tif (i == radiusPlus1) var stackEnd = stack;\n\t\t}\n\t\tstack.next = stackStart;\n\t\tvar stackIn = null;\n\t\tvar stackOut = null;\n\n\t\tyw = yi = 0;\n\n\t\tvar mul_sum = mul_table[radius];\n\t\tvar shg_sum = shg_table[radius];\n\n\t\tfor (y = 0; y < height; y++)\n\t\t{\n\t\t\tr_in_sum = g_in_sum = b_in_sum = a_in_sum = r_sum = g_sum = b_sum = a_sum = 0;\n\n\t\t\tr_out_sum = radiusPlus1 * (pr = pixels[yi]);\n\t\t\tg_out_sum = radiusPlus1 * (pg = pixels[yi+1]);\n\t\t\tb_out_sum = radiusPlus1 * (pb = pixels[yi+2]);\n\t\t\ta_out_sum = radiusPlus1 * (pa = pixels[yi+3]);\n\n\t\t\tr_sum += sumFactor * pr;\n\t\t\tg_sum += sumFactor * pg;\n\t\t\tb_sum += sumFactor * pb;\n\t\t\ta_sum += sumFactor * pa;\n\n\t\t\tstack = stackStart;\n\n\t\t\tfor (i = 0; i < radiusPlus1; i++)\n\t\t\t{\n\t\t\t\tstack.r = pr;\n\t\t\t\tstack.g = pg;\n\t\t\t\tstack.b = pb;\n\t\t\t\tstack.a = pa;\n\t\t\t\tstack = stack.next;\n\t\t\t}\n\n\t\t\tfor (i = 1; i < radiusPlus1; i++)\n\t\t\t{\n\t\t\t\tp = yi + ((widthMinus1 < i ? widthMinus1 : i) << 2);\n\t\t\t\tr_sum += (stack.r = (pr = pixels[p])) * (rbs = radiusPlus1 - i);\n\t\t\t\tg_sum += (stack.g = (pg = pixels[p+1])) * rbs;\n\t\t\t\tb_sum += (stack.b = (pb = pixels[p+2])) * rbs;\n\t\t\t\ta_sum += (stack.a = (pa = pixels[p+3])) * rbs;\n\n\t\t\t\tr_in_sum += pr;\n\t\t\t\tg_in_sum += pg;\n\t\t\t\tb_in_sum += pb;\n\t\t\t\ta_in_sum += pa;\n\n\t\t\t\tstack = stack.next;\n\t\t\t}\n\n\n\t\t\tstackIn = stackStart;\n\t\t\tstackOut = stackEnd;\n\t\t\tfor (x = 0; x < width; x++)\n\t\t\t{\n\t\t\t\tpixels[yi+3] = pa = (a_sum * mul_sum) >> shg_sum;\n\t\t\t\tif (pa != 0)\n\t\t\t\t{\n\t\t\t\t\tpa = 255 / pa;\n\t\t\t\t\tpixels[yi]   = ((r_sum * mul_sum) >> shg_sum) * pa;\n\t\t\t\t\tpixels[yi+1] = ((g_sum * mul_sum) >> shg_sum) * pa;\n\t\t\t\t\tpixels[yi+2] = ((b_sum * mul_sum) >> shg_sum) * pa;\n\t\t\t\t} else {\n\t\t\t\t\tpixels[yi] = pixels[yi+1] = pixels[yi+2] = 0;\n\t\t\t\t}\n\n\t\t\t\tr_sum -= r_out_sum;\n\t\t\t\tg_sum -= g_out_sum;\n\t\t\t\tb_sum -= b_out_sum;\n\t\t\t\ta_sum -= a_out_sum;\n\n\t\t\t\tr_out_sum -= stackIn.r;\n\t\t\t\tg_out_sum -= stackIn.g;\n\t\t\t\tb_out_sum -= stackIn.b;\n\t\t\t\ta_out_sum -= stackIn.a;\n\n\t\t\t\tp =  (yw + ((p = x + radius + 1) < widthMinus1 ? p : widthMinus1)) << 2;\n\n\t\t\t\tr_in_sum += (stackIn.r = pixels[p]);\n\t\t\t\tg_in_sum += (stackIn.g = pixels[p+1]);\n\t\t\t\tb_in_sum += (stackIn.b = pixels[p+2]);\n\t\t\t\ta_in_sum += (stackIn.a = pixels[p+3]);\n\n\t\t\t\tr_sum += r_in_sum;\n\t\t\t\tg_sum += g_in_sum;\n\t\t\t\tb_sum += b_in_sum;\n\t\t\t\ta_sum += a_in_sum;\n\n\t\t\t\tstackIn = stackIn.next;\n\n\t\t\t\tr_out_sum += (pr = stackOut.r);\n\t\t\t\tg_out_sum += (pg = stackOut.g);\n\t\t\t\tb_out_sum += (pb = stackOut.b);\n\t\t\t\ta_out_sum += (pa = stackOut.a);\n\n\t\t\t\tr_in_sum -= pr;\n\t\t\t\tg_in_sum -= pg;\n\t\t\t\tb_in_sum -= pb;\n\t\t\t\ta_in_sum -= pa;\n\n\t\t\t\tstackOut = stackOut.next;\n\n\t\t\t\tyi += 4;\n\t\t\t}\n\t\t\tyw += width;\n\t\t}\n\n\n\t\tfor (x = 0; x < width; x++)\n\t\t{\n\t\t\tg_in_sum = b_in_sum = a_in_sum = r_in_sum = g_sum = b_sum = a_sum = r_sum = 0;\n\n\t\t\tyi = x << 2;\n\t\t\tr_out_sum = radiusPlus1 * (pr = pixels[yi]);\n\t\t\tg_out_sum = radiusPlus1 * (pg = pixels[yi+1]);\n\t\t\tb_out_sum = radiusPlus1 * (pb = pixels[yi+2]);\n\t\t\ta_out_sum = radiusPlus1 * (pa = pixels[yi+3]);\n\n\t\t\tr_sum += sumFactor * pr;\n\t\t\tg_sum += sumFactor * pg;\n\t\t\tb_sum += sumFactor * pb;\n\t\t\ta_sum += sumFactor * pa;\n\n\t\t\tstack = stackStart;\n\n\t\t\tfor (i = 0; i < radiusPlus1; i++)\n\t\t\t{\n\t\t\t\tstack.r = pr;\n\t\t\t\tstack.g = pg;\n\t\t\t\tstack.b = pb;\n\t\t\t\tstack.a = pa;\n\t\t\t\tstack = stack.next;\n\t\t\t}\n\n\t\t\typ = width;\n\n\t\t\tfor (i = 1; i <= radius; i++)\n\t\t\t{\n\t\t\t\tyi = (yp + x) << 2;\n\n\t\t\t\tr_sum += (stack.r = (pr = pixels[yi])) * (rbs = radiusPlus1 - i);\n\t\t\t\tg_sum += (stack.g = (pg = pixels[yi+1])) * rbs;\n\t\t\t\tb_sum += (stack.b = (pb = pixels[yi+2])) * rbs;\n\t\t\t\ta_sum += (stack.a = (pa = pixels[yi+3])) * rbs;\n\n\t\t\t\tr_in_sum += pr;\n\t\t\t\tg_in_sum += pg;\n\t\t\t\tb_in_sum += pb;\n\t\t\t\ta_in_sum += pa;\n\n\t\t\t\tstack = stack.next;\n\n\t\t\t\tif(i < heightMinus1)\n\t\t\t\t{\n\t\t\t\t\typ += width;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tyi = x;\n\t\t\tstackIn = stackStart;\n\t\t\tstackOut = stackEnd;\n\t\t\tfor (y = 0; y < height; y++)\n\t\t\t{\n\t\t\t\tp = yi << 2;\n\t\t\t\tpixels[p+3] = pa = (a_sum * mul_sum) >> shg_sum;\n\t\t\t\tif (pa > 0)\n\t\t\t\t{\n\t\t\t\t\tpa = 255 / pa;\n\t\t\t\t\tpixels[p]   = ((r_sum * mul_sum) >> shg_sum) * pa;\n\t\t\t\t\tpixels[p+1] = ((g_sum * mul_sum) >> shg_sum) * pa;\n\t\t\t\t\tpixels[p+2] = ((b_sum * mul_sum) >> shg_sum) * pa;\n\t\t\t\t} else {\n\t\t\t\t\tpixels[p] = pixels[p+1] = pixels[p+2] = 0;\n\t\t\t\t}\n\n\t\t\t\tr_sum -= r_out_sum;\n\t\t\t\tg_sum -= g_out_sum;\n\t\t\t\tb_sum -= b_out_sum;\n\t\t\t\ta_sum -= a_out_sum;\n\n\t\t\t\tr_out_sum -= stackIn.r;\n\t\t\t\tg_out_sum -= stackIn.g;\n\t\t\t\tb_out_sum -= stackIn.b;\n\t\t\t\ta_out_sum -= stackIn.a;\n\n\t\t\t\tp = (x + (((p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1) * width)) << 2;\n\n\t\t\t\tr_sum += (r_in_sum += (stackIn.r = pixels[p]));\n\t\t\t\tg_sum += (g_in_sum += (stackIn.g = pixels[p+1]));\n\t\t\t\tb_sum += (b_in_sum += (stackIn.b = pixels[p+2]));\n\t\t\t\ta_sum += (a_in_sum += (stackIn.a = pixels[p+3]));\n\n\t\t\t\tstackIn = stackIn.next;\n\n\t\t\t\tr_out_sum += (pr = stackOut.r);\n\t\t\t\tg_out_sum += (pg = stackOut.g);\n\t\t\t\tb_out_sum += (pb = stackOut.b);\n\t\t\t\ta_out_sum += (pa = stackOut.a);\n\n\t\t\t\tr_in_sum -= pr;\n\t\t\t\tg_in_sum -= pg;\n\t\t\t\tb_in_sum -= pb;\n\t\t\t\ta_in_sum -= pa;\n\n\t\t\t\tstackOut = stackOut.next;\n\n\t\t\t\tyi += width;\n\t\t\t}\n\t\t}\n\t\treturn imageData;\n\t}\n\n\tfunction BlurStack()\n\t{\n\t\tthis.r = 0;\n\t\tthis.g = 0;\n\t\tthis.b = 0;\n\t\tthis.a = 0;\n\t\tthis.next = null;\n\t}\n\n\treturn processCanvasRGBA;\n\n}());\n\n// custom event polyfill for IE10\n'use strict';\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n(function () {\n    function CustomEvent(event, params) {\n        params = params || { bubbles: false, cancelable: false, detail: undefined };\n        var evt = document.createEvent('CustomEvent');\n        evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n        return evt;\n    }\n    CustomEvent.prototype = window.CustomEvent.prototype;\n    window.CustomEvent = CustomEvent;\n})();\n\n// canvas to blob polyfill\n// https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob#Polyfill\nif (!HTMLCanvasElement.prototype.toBlob) {\n    Object.defineProperty(HTMLCanvasElement.prototype, 'toBlob', {\n        value: function value(callback, type, quality) {\n\n            var binStr = atob(this.toDataURL(type, quality).split(',')[1]),\n                len = binStr.length,\n                arr = new Uint8Array(len);\n\n            for (var i = 0; i < len; i++) {\n                arr[i] = binStr.charCodeAt(i);\n            }\n\n            callback(new Blob([arr], { type: type || 'image/png' }));\n        }\n    });\n}\n\nfunction getElementAttributes(el) {\n    return Array.prototype.slice.call(el.attributes).map(function (attr) {\n        return { 'name': attr.name, 'value': attr.value };\n    });\n}\n\n// helper method\nfunction getOffsetByEvent(e) {\n    return {\n        x: typeof e.offsetX === 'undefined' ? e.layerX : e.offsetX,\n        y: typeof e.offsetY === 'undefined' ? e.layerY : e.offsetY\n    };\n}\n\n// merge two objects together\nfunction mergeOptions(base, additives) {\n\n    var key;\n    var options = {};\n    var optionsToMerge = additives || {};\n\n    for (key in base) {\n        if (!base.hasOwnProperty(key)) {\n            continue;\n        }\n        options[key] = typeof optionsToMerge[key] === 'undefined' ? base[key] : optionsToMerge[key];\n    }\n\n    return options;\n}\n\n// keys\nvar Key = {\n    ESC: 27,\n    RETURN: 13\n};\n\n// pointer events\nvar Events = {\n    DOWN: ['touchstart', 'pointerdown', 'mousedown'],\n    MOVE: ['touchmove', 'pointermove', 'mousemove'],\n    UP: ['touchend', 'touchcancel', 'pointerup', 'mouseup']\n};\n\n// shortcuts\nfunction create(name, className) {\n    var node = document.createElement(name);\n    if (className) {\n        node.className = className;\n    }\n    return node;\n}\n\n// events\nfunction addEvents(obj, events, scope) {\n    events.forEach(function (event) {\n        obj.addEventListener(event, scope, false);\n    });\n}\n\nfunction removeEvents(obj, events, scope) {\n    events.forEach(function (event) {\n        obj.removeEventListener(event, scope, false);\n    });\n}\n\nfunction getEventOffset(e) {\n\n    var event = e.changedTouches ? e.changedTouches[0] : e;\n\n    // no event found, quit!\n    if (!event) {\n        return;\n    }\n\n    // get offset from events\n    return {\n        x: event.pageX,\n        y: event.pageY\n    };\n}\n\nfunction getEventOffsetLocal(e, local) {\n\n    var offset = getEventOffset(e);\n    var rect = local.getBoundingClientRect();\n    var top = window.pageYOffset || document.documentElement.scrollTop;\n    var left = window.pageXOffset || document.documentElement.scrollLeft;\n\n    return {\n        x: offset.x - rect.left - left,\n        y: offset.y - rect.top - top\n    };\n}\n\nfunction capitalizeFirstLetter(string) {\n    return string.charAt(0).toUpperCase() + string.slice(1);\n}\n\nfunction last(array) {\n    return array[array.length - 1];\n}\n\nfunction limit(value, min, max) {\n    return Math.max(min, Math.min(max, value));\n}\n\nfunction cloneRect(rect) {\n    return {\n        x: rect.x,\n        y: rect.y,\n        width: rect.width,\n        height: rect.height\n    };\n}\n\nfunction inArray(needle, arr) {\n    return arr.indexOf(needle) !== -1;\n}\n\nfunction getExtensionFromFileName(fileName) {\n    return fileName.split('.').pop().toLowerCase();\n}\n\nfunction urlToImage(url) {\n    var img = new Image();\n    img.src = url;\n    return img;\n}\n\nfunction imageToData(img) {\n    var canvas;\n    var ctx;\n    var dataURL;\n\n    canvas = document.createElement('canvas');\n    canvas.width = img.naturalWidth;\n    canvas.height = img.naturalHeight;\n    ctx = canvas.getContext('2d');\n    ctx.drawImage(img, 0, 0);\n    dataURL = canvas.toDataURL();\n    return dataURL;\n}\n\nfunction send(url, data, progress, success, err) {\n\n    var xhr = new XMLHttpRequest();\n\n    if (progress) {\n        xhr.upload.addEventListener('progress', function (e) {\n            progress(e.loaded, e.total);\n        });\n    }\n\n    xhr.open('POST', url, true);\n\n    xhr.onreadystatechange = function () {\n\n        if (xhr.readyState === 4 && xhr.status === 200) {\n\n            var text = xhr.responseText;\n\n            // if no data returned from server assume success\n            if (!text.length) {\n                success();\n                return;\n            }\n\n            // catch possible PHP content length problem\n            if (text.indexOf('Content-Length') !== -1) {\n                err('file-too-big');\n                return;\n            }\n\n            // if data returned it should be in suggested JSON format\n            var obj = null;\n            try {\n                obj = JSON.parse(xhr.responseText);\n            } catch (e) {}\n\n            success(obj || text);\n        } else if (xhr.readyState === 4) {\n            err('fail');\n        }\n    };\n\n    xhr.send(data);\n}\n\nfunction resetTransforms(element) {\n    element.style.transform = '';\n}\n\nfunction revealElement(element, duration) {\n    snabbt(element, {\n        fromOpacity: 0,\n        opacity: 1,\n        duration: duration,\n        complete: function complete() {\n            resetTransforms(this);\n        }\n    });\n}\n\nfunction bytesToMegaBytes(b) {\n    return b / 1000000;\n}\n\nfunction megaBytesToBytes(mb) {\n    return mb * 1000000;\n}\n\nvar mimetypes = {\n    'jpeg': 'image/jpeg',\n    'jpg': 'image/jpeg',\n    'jpe': 'image/jpeg',\n    'png': 'image/png',\n    'gif': 'image/gif',\n    'bmp': 'image/bmp'\n};\n\nfunction getCommonMimeTypes() {\n    var types = [];\n    var type = undefined;\n    var mimetype = undefined;\n    for (type in mimetypes) {\n        mimetype = mimetypes[type];\n        if (types.indexOf(mimetype) == -1) {\n            types.push(mimetype);\n        }\n    }\n    return types;\n}\n\nfunction getExtensionByMimeType(mimetype) {\n    var type = undefined;\n    for (type in mimetypes) {\n        if (mimetypes[type] === mimetype) {\n            return type;\n        }\n    }\n    return mimetype;\n}\n\nfunction getFileMimeType(extension) {\n    return mimetypes[extension] || 'unknown';\n}\n\nfunction getFileMetaData(file) {\n\n    if (typeof file === 'string') {\n\n        // test if is data uri\n        if (/^data:image/.test(file)) {\n            return {\n                name: 'unknown',\n                type: getMimeTypeFromDataURI(file),\n                size: null\n            };\n        }\n\n        // is url\n        return {\n            name: file.split('/').pop(),\n            type: getFileMimeType(file.split('.').pop()),\n            size: null\n        };\n    }\n\n    return {\n        name: file.name,\n        type: file.type,\n        size: file.size\n    };\n}\n\nfunction getImage(src) {\n\n    return loadImage(src);\n}\n\nfunction getImageAsCanvas(src, callback) {\n\n    loadImage.parseMetaData(src, function (meta) {\n\n        var options = {\n            canvas: true,\n            crossOrigin: true\n        };\n\n        if (meta.exif) {\n            options.orientation = meta.exif.get('Orientation');\n        }\n\n        loadImage(src, function (res) {\n\n            if (res.type === 'error') {\n                callback();\n                return;\n            }\n\n            callback(res, meta);\n        }, options);\n    });\n}\n\nfunction getAutoCropRect(width, height, ratioOut) {\n\n    var x,\n        y,\n        w,\n        h,\n        ratioIn = height / width;\n\n    // if input is portrait and required is landscape\n    // width is portrait width, height is width times outputRatio\n    if (ratioIn < ratioOut) {\n        h = height;\n        w = h / ratioOut;\n        x = (width - w) * .5;\n        y = 0;\n    }\n\n    // if input is landscape and required is portrait\n    // height is landscape height, width is height divided by outputRatio\n    else {\n            w = width;\n            h = w * ratioOut;\n            x = 0;\n            y = (height - h) * .5;\n        }\n\n    return {\n        x: x,\n        y: y,\n        height: h,\n        width: w\n    };\n}\n\nfunction cropImage(src, callback, rect) {\n\n    if ('toDataURL' in src) {\n        src = src.toDataURL();\n    }\n\n    loadImage(src, function (image) {\n        callback(image);\n    }, {\n        canvas: true,\n        left: rect.x,\n        top: rect.y,\n        sourceWidth: rect.width,\n        sourceHeight: rect.height\n    });\n}\n\nfunction transformCanvas(canvas, transforms, cb) {\n    if (transforms === undefined) transforms = {};\n\n    var result = create('canvas');\n\n    var space = {\n        width: canvas.width,\n        height: canvas.height\n    };\n\n    var crop = transforms.crop;\n    var size = transforms.size;\n\n    // do crop transforms\n    if (crop) {\n\n        result.width = crop.width;\n        result.height = crop.height;\n\n        // limit crop to size of canvas else safari might return transparant image\n        crop = roundRect(crop);\n        if (crop.y + crop.height > space.height) {\n            crop.y = Math.max(0, space.height - crop.height);\n        }\n        if (crop.x + crop.width > space.width) {\n            crop.x = Math.max(0, space.width - crop.width);\n        }\n\n        var ctx = result.getContext('2d');\n        ctx.drawImage(canvas, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);\n    }\n\n    // do size transforms\n    if (size) {\n\n        // pick smallest scalar\n        scaleCanvas(result, Math.min(size.width / result.width, size.height / result.height));\n    }\n\n    cb(result);\n}\n\nfunction cropCanvas(canvas, callback, rect) {\n\n    var result = create('canvas');\n    result.width = rect.width;\n    result.height = rect.height;\n    var ctx = result.getContext('2d');\n    ctx.drawImage(canvas, rect.x, rect.y, rect.width, rect.height, 0, 0, rect.width, rect.height);\n\n    callback(result);\n}\n\nfunction scaleCanvas(canvas, scalar) {\n\n    // if not scaling down, bail out\n    if (scalar >= 1) {\n        return;\n    }\n\n    var c = cloneCanvas(canvas);\n    var ctx;\n    var width = canvas.width;\n    var height = canvas.height;\n    var targetWidth = Math.ceil(canvas.width * scalar);\n    var targetHeight = Math.ceil(canvas.height * scalar);\n\n    // scale down in steps\n    while (width > targetWidth) {\n\n        width *= .5;\n        height *= .5;\n\n        if (width < targetWidth) {\n            // skip to final draw\n            break;\n        }\n\n        c = create('canvas');\n        c.width = width;\n        c.height = height;\n        ctx = c.getContext('2d');\n        ctx.drawImage(canvas, 0, 0, width, height);\n    }\n\n    // draw final result back to original canvas\n    canvas.width = targetWidth;\n    canvas.height = targetHeight;\n    ctx = canvas.getContext('2d');\n    ctx.drawImage(c, 0, 0, targetWidth, targetHeight);\n}\n\nfunction cloneCanvas(original) {\n    return cloneCanvasScaled(original, 1);\n}\n\nfunction cloneCanvasScaled(original, scalar) {\n\n    if (!original) {\n        return null;\n    }\n\n    var duplicate = document.createElement('canvas');\n    duplicate.setAttribute('data-file', original.getAttribute('data-file'));\n    var ctx = duplicate.getContext('2d');\n    duplicate.width = original.width;\n    duplicate.height = original.height;\n    ctx.drawImage(original, 0, 0);\n    if (scalar > 0 && scalar != 1) {\n        scaleCanvas(duplicate, scalar);\n    }\n    return duplicate;\n}\n\nfunction canvasHasDimensions(canvas) {\n    return canvas.width && canvas.height;\n}\n\nfunction copyCanvas(original, destination) {\n\n    var ctx = destination.getContext('2d');\n    if (canvasHasDimensions(destination)) {\n        ctx.drawImage(original, 0, 0, destination.width, destination.height);\n    } else {\n        destination.width = original.width;\n        destination.height = original.height;\n        ctx.drawImage(original, 0, 0);\n    }\n}\n\nfunction clearCanvas(canvas) {\n    var ctx = canvas.getContext('2d');\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n}\n\nfunction blurCanvas(canvas) {\n    stackBlur(canvas, 0, 0, canvas.width, canvas.height, 3);\n}\n\nfunction rotateCanvas(original) {\n\n    var canvas = document.createElement('canvas');\n    var ctx = canvas.getContext('2d');\n    var widthHalf = original.width * .5;\n    var heightHalf = original.height * .5;\n\n    canvas.width = original.height;\n    canvas.height = original.width;\n\n    clearCanvas(canvas);\n\n    ctx.translate(heightHalf, widthHalf);\n    ctx.rotate(90 * Math.PI / 180);\n    ctx.drawImage(original, -widthHalf, -heightHalf);\n\n    return canvas;\n}\n\nfunction scaleRect(rect, scalar) {\n    return {\n        x: rect.x * scalar,\n        y: rect.y * scalar,\n        width: rect.width * scalar,\n        height: rect.height * scalar\n    };\n}\n\nfunction roundRect(rect) {\n    return {\n        x: Math.floor(rect.x),\n        y: Math.floor(rect.y),\n        width: Math.floor(rect.width),\n        height: Math.floor(rect.height)\n    };\n}\n\nfunction resetFileInput(input) {\n\n    // no value, no need to reset\n    if (!input || input.value === '') {\n        return;\n    }\n\n    try {\n        // for modern browsers\n        input.value = '';\n    } catch (err) {}\n\n    // for IE10\n    if (input.value) {\n\n        // quickly append input to temp form and reset form\n        var form = document.createElement('form');\n        var parentNode = input.parentNode;\n        var ref = input.nextSibling;\n        form.appendChild(input);\n        form.reset();\n\n        // re-inject input where it originally was\n        if (ref) {\n            parentNode.insertBefore(input, ref);\n        } else {\n            parentNode.appendChild(input);\n        }\n    }\n}\n\nfunction limit(value, min, max) {\n    return Math.min(Math.max(value, min), max);\n}\n\nfunction clone(obj) {\n    if (!obj) {\n        return obj;\n    }\n    return JSON.parse(JSON.stringify(obj));\n}\n\nfunction cloneData(obj) {\n\n    var input = cloneCanvas(obj.input.image);\n    var output = cloneCanvas(obj.output.image);\n    var dupe = clone(obj);\n    dupe.input.image = input;\n    dupe.output.image = output;\n    return dupe;\n}\n\nfunction getMimeTypeFromDataURI(dataUri) {\n    if (!dataUri) {\n        return null;\n    }\n    var matches = dataUri.match(/^.+;/);\n    if (matches.length) {\n        return matches[0].substring(5, matches[0].length - 1);\n    }\n    return null;\n}\n\nfunction flattenData(obj) {\n    var props = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n\n    var type = null;\n\n    var data = {\n        server: clone(obj.server),\n        meta: clone(obj.meta),\n        input: {\n            name: obj.input.name,\n            type: obj.input.type,\n            size: obj.input.size,\n            width: obj.input.width,\n            height: obj.input.height\n        },\n        output: {\n            width: obj.output.width,\n            height: obj.output.height\n        }\n    };\n\n    if (inArray('input', props)) {\n        data.input.image = obj.input.image.toDataURL(obj.input.type, 1.0);\n    }\n\n    if (inArray('output', props)) {\n        data.output.image = obj.output.image.toDataURL(obj.input.type, 1.0);\n    }\n\n    if (inArray('actions', props)) {\n        data.actions = clone(obj.actions);\n    }\n\n    // correct extension and type if was converted to .png (could happen on older browser)\n    type = getMimeTypeFromDataURI(data.output.image || data.input.image);\n    if (type === 'image/png') {\n        var _name = data.input.name;\n        data.input.name = _name.substr(0, _name.lastIndexOf('.')) + '.png';\n        data.input.type = type;\n    }\n\n    return data;\n}\n\nfunction toggleDisplayBySelector(selector, enabled, root) {\n    var node = root.querySelector(selector);\n    if (!node) {\n        return;\n    }\n    node.style.display = enabled ? '' : 'none';\n}\n\nfunction getAttributeAsInt(element, attr) {\n    return parseInt(element.getAttribute(attr), 10);\n}\n\nfunction nodeListToArray(nl) {\n    return Array.prototype.slice.call(nl);\n}\n\nfunction removeElement(el) {\n    el.parentNode.removeChild(el);\n}\n\nfunction wrap(element) {\n    var wrapper = create('div');\n    if (element.parentNode) {\n        if (element.nextSibling) {\n            element.parentNode.insertBefore(wrapper, element.nextSibling);\n        } else {\n            element.parentNode.appendChild(wrapper);\n        }\n    }\n    wrapper.appendChild(element);\n    return wrapper;\n}\n\nfunction polarToCartesian(centerX, centerY, radius, angleInDegrees) {\n    var angleInRadians = (angleInDegrees - 90) * Math.PI / 180.0;\n\n    return {\n        x: centerX + radius * Math.cos(angleInRadians),\n        y: centerY + radius * Math.sin(angleInRadians)\n    };\n}\n\nfunction describeArc(x, y, radius, startAngle, endAngle) {\n\n    var start = polarToCartesian(x, y, radius, endAngle);\n    var end = polarToCartesian(x, y, radius, startAngle);\n\n    var arcSweep = endAngle - startAngle <= 180 ? '0' : '1';\n\n    var d = ['M', start.x, start.y, 'A', radius, radius, 0, arcSweep, 0, end.x, end.y].join(' ');\n\n    return d;\n}\n\nfunction percentageArc(x, y, radius, p) {\n    return describeArc(x, y, radius, 0, p * 360);\n}\nvar resizers = {\n    'n': function n(rect, offset, space, ratio) {\n\n        var t, r, b, l, w, h, p, d;\n\n        // bottom is fixed\n        b = rect.y + rect.height;\n\n        // intended top\n        t = limit(offset.y, 0, b);\n\n        // if is too small vertically\n        if (b - t < space.min.height) {\n            t = b - space.min.height;\n        }\n\n        // if should scale by ratio, pick width by ratio of new height\n        w = ratio ? (b - t) / ratio : rect.width;\n\n        // check if has fallen below min width or height\n        if (w < space.min.width) {\n            w = space.min.width;\n            t = b - w * ratio;\n        }\n\n        // add half to left and half to right edge\n        p = (w - rect.width) * .5;\n        l = rect.x - p;\n        r = rect.x + rect.width + p;\n\n        // check if any of the edges has moved out of the available space, if so,\n        // set max size of rectangle from original position\n        if (l < 0 || r > space.width) {\n\n            // smallest distance to edge of space\n            d = Math.min(rect.x, space.width - (rect.x + rect.width));\n\n            // new left and right offsets\n            l = rect.x - d;\n            r = rect.x + rect.width + d;\n\n            // resulting width\n            w = r - l;\n\n            // resulting height based on ratio\n            h = w * ratio;\n\n            // new top position\n            t = b - h;\n        }\n\n        return {\n            x: l,\n            y: t,\n            width: r - l,\n            height: b - t\n        };\n    },\n    's': function s(rect, offset, space, ratio) {\n\n        var t, r, b, l, w, h, p, d;\n\n        // top is fixed\n        t = rect.y;\n\n        // intended bottom\n        b = limit(offset.y, t, space.height);\n\n        // if is too small vertically\n        if (b - t < space.min.height) {\n            b = t + space.min.height;\n        }\n\n        // if should scale by ratio, pick width by ratio of new height\n        w = ratio ? (b - t) / ratio : rect.width;\n\n        // check if has fallen below min width or height\n        if (w < space.min.width) {\n            w = space.min.width;\n            b = t + w * ratio;\n        }\n\n        // add half to left and half to right edge\n        p = (w - rect.width) * .5;\n        l = rect.x - p;\n        r = rect.x + rect.width + p;\n\n        // check if any of the edges has moved out of the available space, if so,\n        // set max size of rectangle from original position\n        if (l < 0 || r > space.width) {\n\n            // smallest distance to edge of space\n            d = Math.min(rect.x, space.width - (rect.x + rect.width));\n\n            // new left and right offsets\n            l = rect.x - d;\n            r = rect.x + rect.width + d;\n\n            // resulting width\n            w = r - l;\n\n            // resulting height based on ratio\n            h = w * ratio;\n\n            // new bottom position\n            b = t + h;\n        }\n\n        return {\n            x: l,\n            y: t,\n            width: r - l,\n            height: b - t\n        };\n    },\n    'e': function e(rect, offset, space, ratio) {\n\n        var t, r, b, l, w, h, p, d;\n\n        // left is fixed\n        l = rect.x;\n\n        // intended right edge\n        r = limit(offset.x, l, space.width);\n\n        // if is too small vertically\n        if (r - l < space.min.width) {\n            r = l + space.min.width;\n        }\n\n        // if should scale by ratio, pick height by ratio of new width\n        h = ratio ? (r - l) * ratio : rect.height;\n\n        // check if has fallen below min width or height\n        if (h < space.min.height) {\n            h = space.min.height;\n            r = l + h / ratio;\n        }\n\n        // add half to top and bottom\n        p = (h - rect.height) * .5;\n        t = rect.y - p;\n        b = rect.y + rect.height + p;\n\n        // check if any of the edges has moved out of the available space, if so,\n        // set max size of rectangle from original position\n        if (t < 0 || b > space.height) {\n\n            // smallest distance to edge of space\n            d = Math.min(rect.y, space.height - (rect.y + rect.height));\n\n            // new top and bottom offsets\n            t = rect.y - d;\n            b = rect.y + rect.height + d;\n\n            // resulting height\n            h = b - t;\n\n            // resulting width based on ratio\n            w = h / ratio;\n\n            // new right position\n            r = l + w;\n        }\n\n        return {\n            x: l,\n            y: t,\n            width: r - l,\n            height: b - t\n        };\n    },\n    'w': function w(rect, offset, space, ratio) {\n\n        var t, r, b, l, w, h, p, d;\n\n        // right is fixed\n        r = rect.x + rect.width;\n\n        // intended left edge\n        l = limit(offset.x, 0, r);\n\n        // if is too small vertically\n        if (r - l < space.min.width) {\n            l = r - space.min.width;\n        }\n\n        // if should scale by ratio, pick height by ratio of new width\n        h = ratio ? (r - l) * ratio : rect.height;\n\n        // check if has fallen below min width or height\n        if (h < space.min.height) {\n            h = space.min.height;\n            l = r - h / ratio;\n        }\n\n        // add half to top and bottom\n        p = (h - rect.height) * .5;\n        t = rect.y - p;\n        b = rect.y + rect.height + p;\n\n        // check if any of the edges has moved out of the available space, if so,\n        // set max size of rectangle from original position\n        if (t < 0 || b > space.height) {\n\n            // smallest distance to edge of space\n            d = Math.min(rect.y, space.height - (rect.y + rect.height));\n\n            // new top and bottom offsets\n            t = rect.y - d;\n            b = rect.y + rect.height + d;\n\n            // resulting height\n            h = b - t;\n\n            // resulting width based on ratio\n            w = h / ratio;\n\n            // new right position\n            l = r - w;\n        }\n\n        return {\n            x: l,\n            y: t,\n            width: r - l,\n            height: b - t\n        };\n    },\n    'ne': function ne(rect, offset, space, ratio) {\n\n        var t, r, b, l, w, h, d;\n\n        // left and bottom are fixed\n        l = rect.x;\n        b = rect.y + rect.height;\n\n        // intended right edge\n        r = limit(offset.x, l, space.width);\n\n        // if is too small vertically\n        if (r - l < space.min.width) {\n            r = l + space.min.width;\n        }\n\n        // if should scale by ratio, pick height by ratio of new width\n        h = ratio ? (r - l) * ratio : limit(b - offset.y, space.min.height, b);\n\n        // check if has fallen below min width or height\n        if (h < space.min.height) {\n            h = space.min.height;\n            r = l + h / ratio;\n        }\n\n        // add height difference with original height to top\n        t = rect.y - (h - rect.height);\n\n        // check if any of the edges has moved out of the available space, if so,\n        // set max size of rectangle from original position\n        if (t < 0 || b > space.height) {\n\n            // smallest distance to edge of space\n            d = Math.min(rect.y, space.height - (rect.y + rect.height));\n\n            // new top and bottom offsets\n            t = rect.y - d;\n\n            // resulting height\n            h = b - t;\n\n            // resulting width based on ratio\n            w = h / ratio;\n\n            // new right position\n            r = l + w;\n        }\n\n        return {\n            x: l,\n            y: t,\n            width: r - l,\n            height: b - t\n        };\n    },\n    'se': function se(rect, offset, space, ratio) {\n\n        var t, r, b, l, w, h, d;\n\n        // left and top are fixed\n        l = rect.x;\n        t = rect.y;\n\n        // intended right edge\n        r = limit(offset.x, l, space.width);\n\n        // if is too small vertically\n        if (r - l < space.min.width) {\n            r = l + space.min.width;\n        }\n\n        // if should scale by ratio, pick height by ratio of new width\n        h = ratio ? (r - l) * ratio : limit(offset.y - rect.y, space.min.height, space.height - t);\n\n        // check if has fallen below min width or height\n        if (h < space.min.height) {\n            h = space.min.height;\n            r = l + h / ratio;\n        }\n\n        // add height difference with original height to bottom\n        b = rect.y + rect.height + (h - rect.height);\n\n        // check if any of the edges has moved out of the available space, if so,\n        // set max size of rectangle from original position\n        if (t < 0 || b > space.height) {\n\n            // smallest distance to edge of space\n            d = Math.min(rect.y, space.height - (rect.y + rect.height));\n\n            // new bottom offset\n            b = rect.y + rect.height + d;\n\n            // resulting height\n            h = b - t;\n\n            // resulting width based on ratio\n            w = h / ratio;\n\n            // new right position\n            r = l + w;\n        }\n\n        return {\n            x: l,\n            y: t,\n            width: r - l,\n            height: b - t\n        };\n    },\n    'sw': function sw(rect, offset, space, ratio) {\n\n        var t, r, b, l, w, h, d;\n\n        // right and top are fixed\n        r = rect.x + rect.width;\n        t = rect.y;\n\n        // intended left edge\n        l = limit(offset.x, 0, r);\n\n        // if is too small vertically\n        if (r - l < space.min.width) {\n            l = r - space.min.width;\n        }\n\n        // if should scale by ratio, pick height by ratio of new width\n        h = ratio ? (r - l) * ratio : limit(offset.y - rect.y, space.min.height, space.height - t);\n\n        // check if has fallen below min width or height\n        if (h < space.min.height) {\n            h = space.min.height;\n            l = r - h / ratio;\n        }\n\n        // add height difference with original height to bottom\n        b = rect.y + rect.height + (h - rect.height);\n\n        // check if any of the edges has moved out of the available space, if so,\n        // set max size of rectangle from original position\n        if (t < 0 || b > space.height) {\n\n            // smallest distance to edge of space\n            d = Math.min(rect.y, space.height - (rect.y + rect.height));\n\n            // new bottom offset\n            b = rect.y + rect.height + d;\n\n            // resulting height\n            h = b - t;\n\n            // resulting width based on ratio\n            w = h / ratio;\n\n            // new left position\n            l = r - w;\n        }\n\n        return {\n            x: l,\n            y: t,\n            width: r - l,\n            height: b - t\n        };\n    },\n    'nw': function nw(rect, offset, space, ratio) {\n\n        var t, r, b, l, w, h, d;\n\n        // right and bottom are fixed\n        r = rect.x + rect.width;\n        b = rect.y + rect.height;\n\n        // intended left edge\n        l = limit(offset.x, 0, r);\n\n        // if is too small vertically\n        if (r - l < space.min.width) {\n            l = r - space.min.width;\n        }\n\n        // if should scale by ratio, pick height by ratio of new width\n        h = ratio ? (r - l) * ratio : limit(b - offset.y, space.min.height, b);\n\n        // check if has fallen below min width or height\n        if (h < space.min.height) {\n            h = space.min.height;\n            l = r - h / ratio;\n        }\n\n        // add height difference with original height to bottom\n        t = rect.y - (h - rect.height);\n\n        // check if any of the edges has moved out of the available space, if so,\n        // set max size of rectangle from original position\n        if (t < 0 || b > space.height) {\n\n            // smallest distance to edge of space\n            d = Math.min(rect.y, space.height - (rect.y + rect.height));\n\n            // new bottom offset\n            t = rect.y - d;\n\n            // resulting height\n            h = b - t;\n\n            // resulting width based on ratio\n            w = h / ratio;\n\n            // new left position\n            l = r - w;\n        }\n\n        return {\n            x: l,\n            y: t,\n            width: r - l,\n            height: b - t\n        };\n    }\n\n};\n\n/**\n * CropArea\n */\n\nvar CropArea = (function () {\n    function CropArea() {\n        var element = arguments.length <= 0 || arguments[0] === undefined ? document.createElement('div') : arguments[0];\n\n        _classCallCheck(this, CropArea);\n\n        this._element = element;\n\n        this._interaction = null;\n\n        this._minWidth = 0;\n        this._minHeight = 0;\n\n        this._ratio = null;\n\n        this._rect = {\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        };\n\n        this._space = {\n            width: 0,\n            height: 0\n        };\n\n        this._rectChanged = false;\n\n        this._init();\n    }\n\n    /**\n     * ImageEditor\n     * @param element\n     * @param options\n     * @constructor\n     */\n\n    _createClass(CropArea, [{\n        key: '_init',\n        value: function _init() {\n\n            this._element.className = 'slim-crop-area';\n\n            // lines\n            var lines = create('div', 'grid');\n            this._element.appendChild(lines);\n\n            // corner & edge resize buttons\n            for (var handler in resizers) {\n                if (!resizers.hasOwnProperty(handler)) {\n                    continue;\n                }\n                var _btn = create('button', handler);\n                this._element.appendChild(_btn);\n            }\n            var btn = create('button', 'c');\n            this._element.appendChild(btn);\n\n            addEvents(document, Events.DOWN, this);\n        }\n    }, {\n        key: 'reset',\n        value: function reset() {\n\n            this._interaction = null;\n\n            this._rect = {\n                x: 0,\n                y: 0,\n                width: 0,\n                height: 0\n            };\n\n            this._rectChanged = true;\n\n            this._redraw();\n\n            this._element.dispatchEvent(new CustomEvent('change'));\n        }\n    }, {\n        key: 'rescale',\n        value: function rescale(scale) {\n\n            // no rescale\n            if (scale === 1) {\n                return;\n            }\n\n            this._interaction = null;\n\n            this._rectChanged = true;\n\n            this._rect.x *= scale;\n            this._rect.y *= scale;\n            this._rect.width *= scale;\n            this._rect.height *= scale;\n\n            this._redraw();\n\n            this._element.dispatchEvent(new CustomEvent('change'));\n        }\n    }, {\n        key: 'limit',\n        value: function limit(width, height) {\n            this._space = {\n                width: width,\n                height: height\n            };\n        }\n    }, {\n        key: 'resize',\n        value: function resize(x, y, width, height) {\n\n            this._interaction = null;\n\n            this._rect = {\n                x: x,\n                y: y,\n                width: limit(width, 0, this._space.width),\n                height: limit(height, 0, this._space.height)\n            };\n\n            this._rectChanged = true;\n\n            this._redraw();\n\n            this._element.dispatchEvent(new CustomEvent('change'));\n        }\n    }, {\n        key: 'handleEvent',\n        value: function handleEvent(e) {\n\n            switch (e.type) {\n\n                case 'touchstart':\n                case 'pointerdown':\n                case 'mousedown':\n                    {\n                        this._onStartDrag(e);\n                    }\n                    break;\n                case 'touchmove':\n                case 'pointermove':\n                case 'mousemove':\n                    {\n                        this._onDrag(e);\n                    }\n                    break;\n                case 'touchend':\n                case 'touchcancel':\n                case 'pointerup':\n                case 'mouseup':\n                    {\n                        this._onStopDrag(e);\n                    }\n\n            }\n        }\n    }, {\n        key: '_onStartDrag',\n        value: function _onStartDrag(e) {\n\n            // is not my event?\n            if (!this._element.contains(e.target)) {\n                return;\n            }\n\n            e.preventDefault();\n\n            // listen to drag related events\n            addEvents(document, Events.MOVE, this);\n            addEvents(document, Events.UP, this);\n\n            // now interacting with control\n            this._interaction = {\n                type: e.target.className,\n                offset: getEventOffsetLocal(e, this._element)\n            };\n\n            // now dragging\n            this._element.setAttribute('data-dragging', 'true');\n\n            // start the redraw update loop\n            this._redraw();\n        }\n    }, {\n        key: '_onDrag',\n        value: function _onDrag(e) {\n\n            e.preventDefault();\n\n            // get local offset for this event\n            var offset = getEventOffsetLocal(e, this._element.parentNode);\n            var type = this._interaction.type;\n\n            // drag\n            if (type === 'c') {\n\n                this._rect.x = limit(offset.x - this._interaction.offset.x, 0, this._space.width - this._rect.width);\n                this._rect.y = limit(offset.y - this._interaction.offset.y, 0, this._space.height - this._rect.height);\n            }\n            // resize\n            else if (resizers[type]) {\n\n                    this._rect = resizers[type](this._rect, offset, {\n                        x: 0,\n                        y: 0,\n                        width: this._space.width,\n                        height: this._space.height,\n                        min: {\n                            width: this._minWidth,\n                            height: this._minHeight\n                        }\n                    }, this._ratio);\n                }\n\n            this._rectChanged = true;\n\n            // dispatch\n            this._element.dispatchEvent(new CustomEvent('input'));\n        }\n    }, {\n        key: '_onStopDrag',\n        value: function _onStopDrag(e) {\n\n            e.preventDefault();\n\n            // stop listening to drag related events\n            removeEvents(document, Events.MOVE, this);\n            removeEvents(document, Events.UP, this);\n\n            // no longer interacting, so no need to redraw\n            this._interaction = null;\n\n            // now dragging\n            this._element.setAttribute('data-dragging', 'false');\n\n            // fire change event\n            this._element.dispatchEvent(new CustomEvent('change'));\n        }\n    }, {\n        key: '_redraw',\n        value: function _redraw() {\n            var _this = this;\n\n            if (this._rectChanged) {\n\n                this._element.style.cssText = '\\n                left:' + this._rect.x + 'px;\\n                top:' + this._rect.y + 'px;\\n                width:' + this._rect.width + 'px;\\n                height:' + this._rect.height + 'px;\\n            ';\n\n                this._rectChanged = false;\n            }\n\n            // if no longer interacting with crop area stop here\n            if (!this._interaction) {\n                return;\n            }\n\n            // redraw\n            requestAnimationFrame(function () {\n                return _this._redraw();\n            });\n        }\n    }, {\n        key: 'destroy',\n        value: function destroy() {\n\n            this._interaction = false;\n            this._rectChanged = false;\n\n            removeEvents(document, Events.DOWN, this);\n            removeEvents(document, Events.MOVE, this);\n            removeEvents(document, Events.UP, this);\n\n            removeElement(this._element);\n        }\n    }, {\n        key: 'element',\n        get: function get() {\n            return this._element;\n        }\n    }, {\n        key: 'area',\n        get: function get() {\n            return this._rect;\n        }\n    }, {\n        key: 'dirty',\n        get: function get() {\n            return this._rect.x !== 0 || this._rect.y !== 0 || this._rect.width !== 0 || this._rect.height !== 0;\n        }\n    }, {\n        key: 'minWidth',\n        set: function set(value) {\n            this._minWidth = value;\n        }\n    }, {\n        key: 'minHeight',\n        set: function set(value) {\n            this._minHeight = value;\n        }\n    }, {\n        key: 'ratio',\n        set: function set(value) {\n            this._ratio = value;\n        }\n    }]);\n\n    return CropArea;\n})();\n\nvar ImageEditorButtons = ['cancel', 'confirm'];\n\nvar ImageCropperEvents = ['input', 'change'];\n\nvar ImageEditor = (function () {\n    function ImageEditor() {\n        var element = arguments.length <= 0 || arguments[0] === undefined ? document.createElement('div') : arguments[0];\n        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n        _classCallCheck(this, ImageEditor);\n\n        this._element = element;\n        this._options = mergeOptions(ImageEditor.options(), options);\n\n        this._ratio = null;\n        this._output = null;\n\n        this._input = null;\n\n        this._preview = null;\n        this._previewBlurred = null;\n        this._blurredPreview = false;\n\n        this._cropper = null;\n        this._previewWrapper = null;\n        this._currentWindowSize = {};\n\n        this._btnGroup = null;\n\n        this._init();\n    }\n\n    /**\n     * FileHopper\n     * @param element\n     * @param options\n     * @constructor\n     */\n\n    _createClass(ImageEditor, [{\n        key: '_init',\n        value: function _init() {\n            var _this2 = this;\n\n            this._element.className = 'slim-image-editor';\n\n            // wrapper\n            this._wrapper = create('div', 'slim-wrapper');\n\n            // photo crop mark container\n            this._stage = create('div', 'slim-stage');\n            this._wrapper.appendChild(this._stage);\n\n            // create crop marks\n            this._cropper = new CropArea();\n            ImageCropperEvents.forEach(function (e) {\n                _this2._cropper.element.addEventListener(e, _this2);\n            });\n            this._stage.appendChild(this._cropper.element);\n\n            // canvas ghost\n            this._previewWrapper = create('div', 'slim-image-editor-preview slim-crop-preview');\n            this._previewBlurred = create('canvas', 'slim-crop-blur');\n            this._previewWrapper.appendChild(this._previewBlurred);\n            this._wrapper.appendChild(this._previewWrapper);\n\n            this._preview = create('img', 'slim-crop');\n            this._previewWrapper.appendChild(this._preview);\n\n            // buttons\n            this._btnGroup = create('div', 'slim-btn-group');\n            ImageEditorButtons.forEach(function (c) {\n                var prop = capitalizeFirstLetter(c);\n                var label = _this2._options['button' + prop + 'Label'];\n                var title = _this2._options['button' + prop + 'Title'];\n                var className = _this2._options['button' + prop + 'ClassName'];\n                var btn = create('button', 'slim-image-editor-btn slim-btn-' + c + (className ? ' ' + className : ''));\n                btn.innerHTML = label;\n                btn.title = title || label;\n                btn.type = 'button';\n                btn.setAttribute('data-action', c);\n                btn.addEventListener('click', _this2);\n                _this2._btnGroup.appendChild(btn);\n            });\n\n            this._element.appendChild(this._wrapper);\n            this._element.appendChild(this._btnGroup);\n        }\n    }, {\n        key: 'handleEvent',\n        value: function handleEvent(e) {\n\n            switch (e.type) {\n                case 'click':\n                    this._onClick(e);\n                    break;\n                case 'change':\n                    this._onGridChange(e);\n                    break;\n                case 'input':\n                    this._onGridInput(e);\n                    break;\n                case 'keydown':\n                    this._onKeyDown(e);\n                    break;\n                case 'resize':\n                    this._onResize(e);\n                    break;\n            }\n        }\n    }, {\n        key: '_onKeyDown',\n        value: function _onKeyDown(e) {\n\n            switch (e.keyCode) {\n                case Key.RETURN:\n                    {\n                        this._confirm();\n                        break;\n                    }\n                case Key.ESC:\n                    {\n                        this._cancel();\n                        break;\n                    }\n            }\n        }\n    }, {\n        key: '_onClick',\n        value: function _onClick(e) {\n\n            if (e.target.classList.contains('slim-btn-cancel')) {\n                this._cancel();\n            }\n\n            if (e.target.classList.contains('slim-btn-confirm')) {\n                this._confirm();\n            }\n        }\n    }, {\n        key: '_onResize',\n        value: function _onResize() {\n            var _this3 = this;\n\n            // remember window size\n            this._currentWindowSize = {\n                width: window.innerWidth,\n                height: window.innerHeight\n            };\n\n            // now let's resize\n            clearTimeout(this._resizeTimer);\n            this._resizeTimer = setTimeout(function () {\n\n                requestAnimationFrame(function () {\n\n                    _this3._reflow();\n                });\n            }, 10);\n        }\n    }, {\n        key: '_reflow',\n        value: function _reflow() {\n\n            // width before scale change\n            var currentWidth = this._wrapper.offsetWidth;\n\n            // let's redraw the image area\n            this._redraw();\n\n            // now let's rescale the cropper\n            this._cropper.rescale(this._wrapper.offsetWidth / currentWidth);\n        }\n    }, {\n        key: '_onGridInput',\n        value: function _onGridInput() {\n\n            this._maskOriginal();\n        }\n    }, {\n        key: '_onGridChange',\n        value: function _onGridChange() {\n\n            this._maskOriginal();\n        }\n    }, {\n        key: '_cancel',\n        value: function _cancel() {\n\n            this._element.dispatchEvent(new CustomEvent('cancel'));\n        }\n    }, {\n        key: '_confirm',\n        value: function _confirm() {\n\n            this._element.dispatchEvent(new CustomEvent('confirm', {\n                detail: {\n                    crop: scaleRect(this._cropper.area, this._input.width / this._preview.width)\n                }\n            }));\n        }\n    }, {\n        key: 'open',\n        value: function open(image, ratio, crop, callback) {\n            var _this4 = this;\n\n            // store original width of input element for later use reference\n            if (this._input && this._input.getAttribute('data-file') == image.getAttribute('data-file')) {\n                callback();\n                return;\n            }\n\n            // we'll always have to blur the preview of a newly opened image\n            this._blurredPreview = false;\n\n            // set as new input image\n            this._input = image;\n            this._preview.onload = function () {\n\n                // redraw view (for first time)\n                _this4._redraw();\n\n                // wait till redrawn and then setup initial cropper\n                requestAnimationFrame(function () {\n\n                    var ratio = _this4.ratio;\n\n                    _this4._cropper.minWidth = _this4._options.minSize.width * _this4.scalar;\n                    _this4._cropper.minHeight = _this4._options.minSize.height * _this4.scalar;\n                    _this4._cropper.ratio = ratio;\n\n                    var rect = _this4._stage.getBoundingClientRect();\n                    _this4._cropper.limit(rect.width, rect.height);\n                    _this4._cropper.resize(crop.x * _this4.scalar, crop.y * _this4.scalar, crop.width * _this4.scalar, crop.height * _this4.scalar);\n\n                    // done\n                    callback();\n\n                    // fade in\n                    _this4._element.style.opacity = '';\n                });\n            };\n\n            // preview\n            var scalar = Math.min(this._element.offsetWidth / this._input.width, this._element.offsetHeight / this._input.height);\n            this._preview.src = cloneCanvasScaled(this._input, scalar).toDataURL();\n\n            // hide editor\n            this._element.style.opacity = '0';\n\n            // set ratio\n            this._ratio = ratio;\n        }\n    }, {\n        key: '_maskOriginal',\n        value: function _maskOriginal() {\n            var _this5 = this;\n\n            // get cropper area\n            var rect = this._cropper.area;\n\n            // update on next frame (so it's in sync with crop area redraw)\n            requestAnimationFrame(function () {\n\n                // show only crop area of original image\n                _this5._preview.style.clip = 'rect(' + rect.y + 'px,' + (rect.x + rect.width) + 'px,' + (rect.y + rect.height) + 'px,' + rect.x + 'px)';\n            });\n        }\n    }, {\n        key: '_reset',\n        value: function _reset() {\n\n            this._blurredPreview = false;\n\n            // remove preview image\n            this._preview.src = '';\n\n            // clear canvas\n            clearCanvas(this._previewBlurred);\n\n            // reset grid\n            this._cropper.reset();\n        }\n    }, {\n        key: '_redraw',\n        value: function _redraw() {\n\n            // image ratio\n            var ratio = this._input.height / this._input.width;\n\n            // determine rounded size\n            var buttonContainerHeight = this._btnGroup.offsetHeight;\n            var maxWidth = this._element.clientWidth;\n            var maxHeight = this._element.clientHeight - buttonContainerHeight;\n\n            var width = maxWidth;\n            var height = width * ratio;\n\n            if (height > maxHeight) {\n                height = maxHeight;\n                width = height / ratio;\n            }\n\n            width = Math.round(width);\n            height = Math.round(height);\n\n            // rescale editor and blurred view\n            this._previewBlurred.style.cssText = this._wrapper.style.cssText = '\\n            width:' + width + 'px;\\n            height:' + height + 'px;\\n        ';\n\n            // set image size based on container dimensions\n            this._preview.width = width;\n            this._preview.height = height;\n\n            // scale and blur the blurry preview\n            if (!this._blurredPreview) {\n\n                this._previewBlurred.width = 300;\n                this._previewBlurred.height = this._previewBlurred.width * ratio;\n\n                copyCanvas(this._input, this._previewBlurred);\n\n                blurCanvas(this._previewBlurred, 3);\n\n                this._blurredPreview = true;\n            }\n        }\n    }, {\n        key: 'show',\n        value: function show() {\n            var callback = arguments.length <= 0 || arguments[0] === undefined ? function () {} : arguments[0];\n\n            if (this._currentWindowSize.width !== window.innerWidth || this._currentWindowSize.height !== window.innerHeight) {\n                this._reflow();\n            }\n\n            // listen to keydown so we can close or confirm with RETURN / ESC\n            document.addEventListener('keydown', this);\n\n            // when window is scaled we want to resize the editor\n            window.addEventListener('resize', this);\n\n            // fade in preview\n            snabbt(this._previewWrapper, {\n                fromPosition: [0, 0, 0],\n                position: [0, 0, 0],\n                fromOpacity: 0,\n                opacity: .9999, // fixes IE render bug\n                fromScale: [.98, .98],\n                scale: [1, 1],\n                easing: 'spring',\n                springConstant: .3,\n                springDeceleration: .85,\n                delay: 450,\n                complete: function complete() {\n                    resetTransforms(this);\n                }\n            });\n\n            if (this._cropper.dirty) {\n\n                // now show slicer\n                snabbt(this._stage, {\n                    fromPosition: [0, 0, 0],\n                    position: [0, 0, 0],\n                    fromOpacity: 0,\n                    opacity: 1,\n                    duration: 250,\n                    delay: 550,\n                    complete: function complete() {\n                        resetTransforms(this);\n                        callback();\n                    }\n                });\n            } else {\n\n                // now show slicer\n                snabbt(this._stage, {\n                    fromPosition: [0, 0, 0],\n                    position: [0, 0, 0],\n                    fromOpacity: 0,\n                    opacity: 1,\n                    duration: 250,\n                    delay: 1000,\n                    complete: function complete() {\n                        resetTransforms(this);\n                    }\n                });\n            }\n\n            // now show cancel\n            snabbt(this._btnGroup.childNodes, {\n                fromScale: [.9, .9],\n                scale: [1, 1],\n                fromOpacity: 0,\n                opacity: 1,\n                delay: function delay(i) {\n                    return 1000 + i * 100;\n                },\n                easing: 'spring',\n                springConstant: .3,\n                springDeceleration: .85,\n                complete: function complete() {\n                    resetTransforms(this);\n                }\n            });\n        }\n    }, {\n        key: 'hide',\n        value: function hide() {\n            var callback = arguments.length <= 0 || arguments[0] === undefined ? function () {} : arguments[0];\n\n            // no more need to listen to keydown\n            document.removeEventListener('keydown', this);\n\n            // no more need to resize editor when window is scaled\n            window.removeEventListener('resize', this);\n\n            // fade out buttons\n            snabbt(this._btnGroup.childNodes, {\n                fromOpacity: 1,\n                opacity: 0,\n                duration: 350\n            });\n\n            snabbt([this._stage, this._previewWrapper], {\n                fromPosition: [0, 0, 0],\n                position: [0, -250, 0],\n                fromOpacity: 1,\n                opacity: 0,\n                easing: 'spring',\n                springConstant: .3,\n                springDeceleration: .75,\n                delay: 250,\n                allDone: function allDone() {\n\n                    callback();\n                }\n            });\n        }\n    }, {\n        key: 'destroy',\n        value: function destroy() {\n            var _this6 = this;\n\n            nodeListToArray(this._btnGroup.children).forEach(function (btn) {\n                btn.removeEventListener('click', _this6);\n            });\n\n            ImageCropperEvents.forEach(function (e) {\n                _this6._cropper.element.removeEventListener(e, _this6);\n            });\n\n            this._cropper.destroy();\n\n            removeElement(this._element);\n        }\n    }, {\n        key: 'element',\n        get: function get() {\n            return this._element;\n        }\n    }, {\n        key: 'ratio',\n        get: function get() {\n            if (this._ratio === 'input') {\n                return this._input.height / this._input.width;\n            }\n            return this._ratio;\n        }\n    }, {\n        key: 'offset',\n        get: function get() {\n            return this._element.getBoundingClientRect();\n        }\n    }, {\n        key: 'original',\n        get: function get() {\n            return this._input;\n        }\n    }, {\n        key: 'scalar',\n        get: function get() {\n            return this._preview.width / this._input.width;\n        }\n    }], [{\n        key: 'options',\n        value: function options() {\n\n            return {\n                buttonCancelClassName: null,\n                buttonConfirmClassName: null,\n                buttonCancelLabel: 'Cancel',\n                buttonConfirmLabel: 'Confirm',\n                buttonCancelTitle: null,\n                buttonConfirmTitle: null,\n                minSize: {\n                    width: 0,\n                    height: 0\n                }\n            };\n        }\n    }]);\n\n    return ImageEditor;\n})();\n\nvar DragDropEvents = ['dragover', 'dragleave', 'drop'];\n\nvar FileHopper = (function () {\n    function FileHopper() {\n        var element = arguments.length <= 0 || arguments[0] === undefined ? document.createElement('div') : arguments[0];\n\n        _classCallCheck(this, FileHopper);\n\n        this._element = element;\n        this._accept = [];\n\n        this._dragPath = null;\n\n        this._init();\n    }\n\n    /**\n     * Popover\n     */\n\n    // public properties\n\n    _createClass(FileHopper, [{\n        key: 'areValidFiles',\n        value: function areValidFiles(files) {\n\n            if (this._accept.length && files) {\n                return this._accept.indexOf(files[0].type) != -1;\n            }\n            return true;\n        }\n\n        // public methods\n    }, {\n        key: 'reset',\n        value: function reset() {\n            this._element.files = null;\n        }\n\n        // private\n    }, {\n        key: '_init',\n        value: function _init() {\n            var _this7 = this;\n\n            this._element.className = 'slim-file-hopper';\n\n            DragDropEvents.forEach(function (e) {\n                _this7._element.addEventListener(e, _this7);\n            });\n        }\n\n        // the input has changed\n    }, {\n        key: 'handleEvent',\n        value: function handleEvent(e) {\n\n            switch (e.type) {\n                case 'dragover':\n                    this._onDragOver(e);\n                    break;\n                case 'dragleave':\n                    this._onDragLeave(e);\n                    break;\n                case 'drop':\n                    this._onDrop(e);\n                    break;\n            }\n        }\n    }, {\n        key: '_onDrop',\n        value: function _onDrop(e) {\n\n            // prevents browser from opening image\n            e.preventDefault();\n\n            // test type in older browsers\n            if (!this.areValidFiles(e.dataTransfer.files)) {\n\n                // invalid files, stop here\n                this._element.dispatchEvent(new CustomEvent('file-invalid-drop'));\n\n                // no longer hovering\n                this._dragPath = null;\n                return;\n            }\n\n            // store dropped files on element files property, so can be accessed by same function as file input handler\n            this._element.files = e.dataTransfer.files;\n\n            // file has been dropped\n            this._element.dispatchEvent(new CustomEvent('file-drop', {\n                detail: getOffsetByEvent(e)\n            }));\n\n            // file list has changed, let's notify others\n            this._element.dispatchEvent(new CustomEvent('change'));\n\n            // no longer hovering\n            this._dragPath = null;\n        }\n    }, {\n        key: '_onDragOver',\n        value: function _onDragOver(e) {\n\n            // prevents browser from opening image\n            e.preventDefault();\n\n            e.dataTransfer.dropEffect = 'copy';\n\n            if (!this.areValidFiles(e.dataTransfer.items)) {\n\n                // indicate drop mode to user\n                e.dataTransfer.dropEffect = 'none';\n\n                // invalid files, stop here\n                this._element.dispatchEvent(new CustomEvent('file-invalid'));\n                return;\n            }\n\n            // now hovering file over the area\n            if (!this._dragPath) {\n                this._dragPath = [];\n            }\n\n            // push location\n            this._dragPath.push(getOffsetByEvent(e));\n\n            // file is hovering over element\n            this._element.dispatchEvent(new CustomEvent('file-over', {\n                detail: {\n                    x: last(this._dragPath).x,\n                    y: last(this._dragPath).y\n                }\n            }));\n        }\n    }, {\n        key: '_onDragLeave',\n        value: function _onDragLeave(e) {\n\n            // user has dragged file out of element area\n            this._element.dispatchEvent(new CustomEvent('file-out', {\n                detail: getOffsetByEvent(e)\n            }));\n\n            // now longer hovering file\n            this._dragPath = null;\n        }\n    }, {\n        key: 'destroy',\n        value: function destroy() {\n            var _this8 = this;\n\n            DragDropEvents.forEach(function (e) {\n                _this8._element.removeEventListener(e, _this8);\n            });\n\n            removeElement(this._element);\n        }\n    }, {\n        key: 'element',\n        get: function get() {\n            return this._element;\n        }\n    }, {\n        key: 'dragPath',\n        get: function get() {\n            return this._dragPath;\n        }\n    }, {\n        key: 'enabled',\n        get: function get() {\n            return this._element.style.display === '';\n        },\n        set: function set(value) {\n            this._element.style.display = value ? '' : 'none';\n        }\n    }, {\n        key: 'accept',\n        set: function set(mimetypes) {\n            this._accept = mimetypes;\n        },\n        get: function get() {\n            return this._accept;\n        }\n    }]);\n\n    return FileHopper;\n})();\n\nvar Popover = (function () {\n    function Popover() {\n        _classCallCheck(this, Popover);\n\n        this._element = null;\n        this._inner = null;\n\n        this._init();\n    }\n\n    /**\n     * Slim API\n     */\n\n    _createClass(Popover, [{\n        key: '_init',\n        value: function _init() {\n\n            this._element = create('div', 'slim-popover');\n            this._element.setAttribute('data-state', 'off');\n            document.body.appendChild(this._element);\n        }\n    }, {\n        key: 'show',\n        value: function show() {\n            var _this9 = this;\n\n            var callback = arguments.length <= 0 || arguments[0] === undefined ? function () {} : arguments[0];\n\n            // turn on\n            this._element.setAttribute('data-state', 'on');\n\n            // show and animate in\n            snabbt(this._element, {\n                fromOpacity: 0,\n                opacity: 1,\n                duration: 350,\n                complete: function complete() {\n\n                    // clean up transforms\n                    resetTransforms(_this9._element);\n\n                    // ready!\n                    callback();\n                }\n            });\n        }\n    }, {\n        key: 'hide',\n        value: function hide() {\n            var _this10 = this;\n\n            var callback = arguments.length <= 0 || arguments[0] === undefined ? function () {} : arguments[0];\n\n            // animate out and hide\n            snabbt(this._element, {\n                fromOpacity: 1,\n                opacity: 0,\n                duration: 500,\n                complete: function complete() {\n\n                    // clean up transforms\n                    resetTransforms(_this10._element);\n\n                    // hide the editor\n                    _this10._element.setAttribute('data-state', 'off');\n\n                    // ready!\n                    callback();\n                }\n            });\n        }\n    }, {\n        key: 'destroy',\n        value: function destroy() {\n            if (!this._element.parentNode) {\n                return;\n            }\n            this._element.parentNode.removeChild(this._element);\n        }\n    }, {\n        key: 'inner',\n        set: function set(element) {\n\n            this._inner = element;\n            if (this._element.firstChild) {\n                this._element.removeChild(this._element.firstChild);\n            }\n            this._element.appendChild(this._inner);\n        }\n    }]);\n\n    return Popover;\n})();\n\nfunction intSplit(v, c) {\n    return v.split(c).map(function (v) {\n        return parseInt(v, 10);\n    });\n}\n\nfunction isWrapper(element) {\n    return element.nodeName == 'DIV';\n}\n\nvar CropType = {\n    AUTO: 'auto',\n    INITIAL: 'initial',\n    MANUAL: 'manual'\n};\n\nvar Rect = ['x', 'y', 'width', 'height'];\n\nvar HopperEvents = ['file-invalid-drop', 'file-invalid', 'file-drop', 'file-over', 'file-out', 'click'];\n\nvar ImageEditorEvents = ['cancel', 'confirm'];\n\nvar SlimPopover = null;\nvar SlimCount = 0;\n\nvar SlimButtons = ['remove', 'edit', 'download', 'upload'];\n\nvar SlimType = {\n    IMG: 'img',\n    INPUT: 'input'\n};\n\nvar SlimLoaderHTML = '\\n<div class=\"slim-loader\">\\n    <svg>\\n        <path class=\"slim-loader-background\" fill=\"none\" stroke-width=\"3\" />\\n        <path class=\"slim-loader-foreground\" fill=\"none\" stroke-width=\"3\" />\\n    </svg>\\n</div>\\n';\n\nvar SlimUploadStatusHTML = '\\n<div class=\"slim-upload-status\"></div>\\n';\n\nvar Slim = (function () {\n    function Slim(element) {\n        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n        _classCallCheck(this, Slim);\n\n        // create popover element if not already created\n        if (!SlimPopover) {\n            SlimPopover = new Popover();\n        }\n\n        // we create a new counter, we use this counter to determine if we need to clean up the popover\n        SlimCount++;\n\n        // the options to use\n        this._options = mergeOptions(Slim.options(), options);\n\n        // reference to original element so we can restore original situation\n        this._originalElement = element;\n        this._originalElementInner = element.innerHTML;\n        this._originalElementAttributes = getElementAttributes(element);\n\n        // should be file input, image or slim wrapper, if not wrapper, wrap\n        if (!isWrapper(element)) {\n\n            this._element = wrap(element);\n            this._element.className = element.className;\n            element.className = '';\n\n            // ratio is used for CSS so let's set default attribute\n            this._element.setAttribute('data-ratio', this._options.ratio);\n        } else {\n            this._element = element;\n        }\n        this._element.classList.add('slim');\n        this._element.setAttribute('data-state', 'init');\n\n        // the source element (can either be an input or an img)\n        this._input = null;\n\n        // the output element (hidden input that contains the resulting json object)\n        this._output = null;\n\n        // current image ratio\n        this._ratio = null;\n\n        // was required field\n        this._isRequired = false;\n\n        // components\n        this._imageHopper = null;\n        this._imageEditor = null;\n\n        // progress path\n        this._progressEnabled = true;\n\n        // resulting data\n        this._data = {};\n        this._resetData();\n\n        // editor state\n        this._state = [];\n\n        // the circle below the mouse hover point\n        this._drip = null;\n\n        // had initial image\n        this._hasInitialImage = false;\n\n        // initial crop\n        this._initialCrop = this._options.crop;\n\n        // set to true when destroy method is called, used to halt any timeouts or async processes\n        this._isBeingDestroyed = false;\n\n        // let's go!\n        if (Slim.supported) {\n            this._init();\n        } else {\n            this._fallback();\n        }\n    }\n\n    /**\n     * Slim Static Methods\n     */\n\n    _createClass(Slim, [{\n        key: 'isAttachedTo',\n\n        // methods\n        // Test if this Slim object has been bound to the given element\n        value: function isAttachedTo(element) {\n            return this._element === element || this._originalElement === element;\n        }\n    }, {\n        key: 'isDetached',\n        value: function isDetached() {\n            return this._element.parentNode === null;\n        }\n    }, {\n        key: 'load',\n        value: function load(src, options, callback) {\n            if (options === undefined) options = {};\n\n            if (typeof options == 'function') {\n                callback = options;\n            } else {\n\n                // store in options\n                this._options.crop = options.crop;\n\n                // set initial crop\n                this._initialCrop = this._options.crop;\n            }\n\n            this._load(src, callback);\n        }\n    }, {\n        key: 'upload',\n        value: function upload(callback) {\n            this._doUpload(callback);\n        }\n    }, {\n        key: 'download',\n        value: function download() {\n            this._doDownload();\n        }\n    }, {\n        key: 'remove',\n        value: function remove() {\n            return this._doRemove();\n        }\n    }, {\n        key: 'destroy',\n        value: function destroy() {\n            this._doDestroy();\n        }\n\n        /**\n         * State Related\n         */\n    }, {\n        key: '_getFileInput',\n        value: function _getFileInput() {\n            return this._element.querySelector('input[type=file]');\n        }\n    }, {\n        key: '_getInitialImage',\n        value: function _getInitialImage() {\n            return this._element.querySelector('img');\n        }\n    }, {\n        key: '_getInputElement',\n        value: function _getInputElement() {\n            return this._getFileInput() || this._getInitialImage();\n        }\n    }, {\n        key: '_getRatioSpacerElement',\n        value: function _getRatioSpacerElement() {\n            return this._element.children[0];\n        }\n    }, {\n        key: '_isImageOnly',\n        value: function _isImageOnly() {\n            return this._input.nodeName !== 'INPUT';\n        }\n    }, {\n        key: '_isFixedRatio',\n        value: function _isFixedRatio() {\n            return this._options.ratio.indexOf(':') !== -1;\n        }\n    }, {\n        key: '_toggleButton',\n        value: function _toggleButton(action, state) {\n            toggleDisplayBySelector('.slim-btn[data-action=\"' + action + '\"]', state, this._element);\n        }\n    }, {\n        key: '_clearState',\n        value: function _clearState() {\n            this._state = [];\n            this._updateState();\n        }\n    }, {\n        key: '_removeState',\n        value: function _removeState(state) {\n            this._state = this._state.filter(function (item) {\n                return item !== state;\n            });\n            this._updateState();\n        }\n    }, {\n        key: '_addState',\n        value: function _addState(state) {\n            if (inArray(state, this._state)) {\n                return;\n            }\n            this._state.push(state);\n            this._updateState();\n        }\n    }, {\n        key: '_updateState',\n        value: function _updateState() {\n            this._element.setAttribute('data-state', this._state.join(','));\n        }\n    }, {\n        key: '_resetData',\n        value: function _resetData() {\n\n            // resets data object\n            this._data = {\n                server: null,\n                meta: null,\n                input: {\n                    image: null,\n                    name: null,\n                    type: null,\n                    width: 0,\n                    height: 0\n                },\n                output: {\n                    image: null,\n                    width: 0,\n                    height: 0\n                },\n                actions: {\n                    crop: null,\n                    size: null\n                }\n            };\n\n            // resets hidden input clone\n            if (this._output) {\n                this._output.value = '';\n            }\n\n            // should reset file input\n            resetFileInput(this._getFileInput());\n        }\n\n        /**\n         * Initialisation\n         */\n    }, {\n        key: '_init',\n        value: function _init() {\n            var _this11 = this;\n\n            // cropper root is not file input\n            this._addState('empty');\n\n            // get input element\n            this._input = this._getInputElement();\n\n            // if no input supplied we'll automatically create one\n            if (!this._input) {\n                this._input = create('input');\n                this._input.type = 'file';\n                this._element.appendChild(this._input);\n            }\n\n            // get required state of input element\n            this._isRequired = this._input.required === true;\n\n            // set or create output field\n            this._output = this._element.querySelector('input[type=hidden]');\n\n            // if no output element defined we'll create one automagically\n            if (!this._output) {\n                this._output = create('input');\n                this._output.type = 'hidden';\n                this._output.name = this._input.name || this._options.defaultInputName;\n                this._element.appendChild(this._output);\n            }\n\n            // prevent the original file input field from posting (value will be duplicated to output field)\n            this._input.removeAttribute('name');\n\n            // create drop area\n            var area = create('div', 'slim-area');\n\n            // test if contains initial image\n            var initialImage = this._getInitialImage();\n            var initialImageSrc = (initialImage || {}).src;\n            if (initialImageSrc) {\n                this._hasInitialImage = true;\n            } else {\n                this._initialCrop = null;\n            }\n\n            var resultHTML = '\\n        <div class=\"slim-result\">\\n            <img class=\"in\" style=\"opacity:0\" ' + (initialImageSrc ? 'src=\"' + initialImageSrc + '\"' : '') + '><img><img style=\"opacity:0\">\\n        </div>';\n\n            // add drop overlay\n            if (this._isImageOnly()) {\n                area.innerHTML = '\\n                ' + SlimLoaderHTML + '\\n                ' + SlimUploadStatusHTML + '\\n                ' + resultHTML + '\\n            ';\n            } else {\n\n                // set common image mime type to the accept attribute\n                var _mimetypes = undefined;\n                if (!this._input.hasAttribute('accept')) {\n                    _mimetypes = getCommonMimeTypes();\n                    this._input.setAttribute('accept', _mimetypes.join(','));\n                } else {\n                    _mimetypes = this._input.accept.split(',').filter(function (mimetype) {\n                        return mimetype.length > 0;\n                    });\n                }\n\n                // setup hopper\n                this._imageHopper = new FileHopper();\n                this._imageHopper.accept = _mimetypes;\n                this._element.appendChild(this._imageHopper.element);\n                HopperEvents.forEach(function (e) {\n                    _this11._imageHopper.element.addEventListener(e, _this11);\n                });\n\n                // render area\n                area.innerHTML = '\\n                ' + SlimLoaderHTML + '\\n                ' + SlimUploadStatusHTML + '\\n                <div class=\"slim-drip\"><span><span></span></span></div>\\n                <div class=\"slim-status\"><div class=\"slim-label\">' + (this._options.label || '') + '</div></div>\\n                ' + resultHTML + '\\n            ';\n\n                // start listening for events so we can load image on file input change\n                this._input.addEventListener('change', this);\n            }\n\n            // add area node\n            this._element.appendChild(area);\n\n            // add button group\n            this._btnGroup = create('div', 'slim-btn-group');\n            this._btnGroup.style.display = 'none';\n            this._element.appendChild(this._btnGroup);\n            SlimButtons.filter(function (c) {\n                return _this11._isButtonAllowed(c);\n            }).forEach(function (c) {\n                var prop = capitalizeFirstLetter(c);\n                var label = _this11._options['button' + prop + 'Label'];\n                var title = _this11._options['button' + prop + 'Title'] || label;\n                var className = _this11._options['button' + prop + 'ClassName'];\n                var btn = create('button', 'slim-btn slim-btn-' + c + (className ? ' ' + className : ''));\n                btn.innerHTML = label;\n                btn.title = title;\n                btn.type = 'button';\n                btn.addEventListener('click', _this11);\n                btn.setAttribute('data-action', c);\n                _this11._btnGroup.appendChild(btn);\n            });\n\n            // add ratio padding\n            if (this._isFixedRatio()) {\n                var parts = intSplit(this._options.ratio, ':');\n                this._ratio = parts[1] / parts[0];\n                this._scaleDropArea(this._ratio);\n            }\n\n            // setup loader\n            this._updateProgress(.5);\n\n            // preload source\n            if (initialImageSrc) {\n\n                this._load(initialImageSrc, function () {\n\n                    // done loading initial image\n                    _this11._onInit();\n                });\n            } else {\n                this._onInit();\n            }\n        }\n    }, {\n        key: '_onInit',\n        value: function _onInit() {\n            var _this12 = this;\n\n            // done inintialising now, else is only called after image load\n            // we call this async so the constructor of Slim has returned before the onInit is called, allowing clean immidiate destroy\n            setTimeout(function () {\n                _this12._options.onInit(_this12);\n            }, 0);\n        }\n    }, {\n        key: '_updateProgress',\n        value: function _updateProgress(progress) {\n\n            if (!this._progressEnabled) {\n                return;\n            }\n\n            var loader = this._element.querySelector('.slim-loader');\n            if (!loader) {\n                return;\n            }\n            var rect = loader.getBoundingClientRect();\n            var paths = loader.querySelectorAll('path');\n            var ringWidth = parseInt(paths[0].getAttribute('stroke-width'), 10);\n\n            paths[0].setAttribute('d', percentageArc(rect.width * .5, rect.height * .5, rect.width * .5 - ringWidth, .9999));\n\n            paths[1].setAttribute('d', percentageArc(rect.width * .5, rect.height * .5, rect.width * .5 - ringWidth, progress));\n        }\n    }, {\n        key: '_startProgress',\n        value: function _startProgress() {\n            var _this13 = this;\n\n            this._progressEnabled = false;\n\n            var loader = this._element.querySelector('.slim-loader');\n            if (!loader) {\n                return;\n            }\n            var ring = loader.children[0];\n\n            this._stopProgressLoop(function () {\n\n                loader.removeAttribute('style');\n                ring.removeAttribute('style');\n\n                _this13._progressEnabled = true;\n\n                _this13._updateProgress(0);\n\n                _this13._progressEnabled = false;\n\n                snabbt(ring, {\n\n                    fromOpacity: 0,\n                    opacity: 1,\n                    duration: 250,\n                    complete: function complete() {\n                        _this13._progressEnabled = true;\n                    }\n                });\n            });\n        }\n    }, {\n        key: '_stopProgress',\n        value: function _stopProgress() {\n            var _this14 = this;\n\n            var loader = this._element.querySelector('.slim-loader');\n            if (!loader) {\n                return;\n            }\n            var ring = loader.children[0];\n\n            this._updateProgress(1);\n\n            snabbt(ring, {\n                fromOpacity: 1,\n                opacity: 0,\n                duration: 250,\n                complete: function complete() {\n\n                    loader.removeAttribute('style');\n                    ring.removeAttribute('style');\n\n                    _this14._updateProgress(.5);\n\n                    _this14._progressEnabled = false;\n                }\n            });\n        }\n    }, {\n        key: '_startProgressLoop',\n        value: function _startProgressLoop() {\n\n            // start loading animation\n            var loader = this._element.querySelector('.slim-loader');\n            if (!loader) {\n                return;\n            }\n            var ring = loader.children[0];\n            loader.removeAttribute('style');\n            ring.removeAttribute('style');\n\n            // set infinite load state\n            this._updateProgress(.5);\n\n            // repeat!\n            var repeat = 1000;\n\n            snabbt(loader, {\n                rotation: [0, 0, -(Math.PI * 2) * repeat],\n                easing: 'linear',\n                duration: repeat * 1000\n            });\n\n            snabbt(ring, {\n                fromOpacity: 0,\n                opacity: 1,\n                duration: 250\n            });\n        }\n    }, {\n        key: '_stopProgressLoop',\n        value: function _stopProgressLoop(callback) {\n\n            var loader = this._element.querySelector('.slim-loader');\n            if (!loader) {\n                return;\n            }\n            var ring = loader.children[0];\n\n            snabbt(ring, {\n                fromOpacity: parseFloat(ring.style.opacity),\n                opacity: 0,\n                duration: 250,\n                complete: function complete() {\n                    snabbt(loader, 'stop');\n                    if (callback) {\n                        callback();\n                    }\n                }\n            });\n        }\n    }, {\n        key: '_isButtonAllowed',\n        value: function _isButtonAllowed(button) {\n\n            if (button === 'edit') {\n                return this._options.edit;\n            }\n\n            if (button === 'download') {\n                return this._options.download;\n            }\n\n            if (button === 'upload') {\n\n                // if no service defined upload button makes no sense\n                if (!this._options.service) {\n                    return false;\n                }\n\n                // if push mode is set, no need for upload button\n                if (this._options.push) {\n                    return false;\n                }\n\n                // set upload button\n                return true;\n            }\n\n            if (button === 'remove') {\n                return !this._isImageOnly();\n            }\n\n            return true;\n        }\n    }, {\n        key: '_fallback',\n        value: function _fallback() {\n\n            this._removeState('init');\n\n            // create status area\n            var area = create('div', 'slim-area');\n            area.innerHTML = '\\n            <div class=\"slim-status\"><div class=\"slim-label\">' + (this._options.label || '') + '</div></div>\\n        ';\n            this._element.appendChild(area);\n\n            this._throwError(this._options.statusNoSupport);\n        }\n\n        /**\n         * Event routing\n         */\n    }, {\n        key: 'handleEvent',\n        value: function handleEvent(e) {\n\n            switch (e.type) {\n                case 'click':\n                    this._onClick(e);\n                    break;\n                case 'change':\n                    this._onChange(e);\n                    break;\n                case 'cancel':\n                    this._onCancel(e);\n                    break;\n                case 'confirm':\n                    this._onConfirm(e);\n                    break;\n                case 'file-over':\n                    this._onFileOver(e);\n                    break;\n                case 'file-out':\n                    this._onFileOut(e);\n                    break;\n                case 'file-drop':\n                    this._onDropFile(e);\n                    break;\n                case 'file-invalid':\n                    this._onInvalidFile(e);\n                    break;\n                case 'file-invalid-drop':\n                    this._onInvalidFileDrop(e);\n                    break;\n            }\n        }\n    }, {\n        key: '_getIntro',\n        value: function _getIntro() {\n            return this._element.querySelector('.slim-result .in');\n        }\n    }, {\n        key: '_getOutro',\n        value: function _getOutro() {\n            return this._element.querySelector('.slim-result .out');\n        }\n    }, {\n        key: '_getInOut',\n        value: function _getInOut() {\n            return this._element.querySelectorAll('.slim-result img');\n        }\n    }, {\n        key: '_getDrip',\n        value: function _getDrip() {\n            if (!this._drip) {\n                this._drip = this._element.querySelector('.slim-drip > span');\n            }\n            return this._drip;\n        }\n\n        // errors\n    }, {\n        key: '_throwError',\n        value: function _throwError(error) {\n\n            this._addState('error');\n\n            this._element.querySelector('.slim-label').style.display = 'none';\n\n            var node = this._element.querySelector('.slim-error');\n            if (!node) {\n                node = create('div', 'slim-error');\n                this._element.querySelector('.slim-status').appendChild(node);\n            }\n\n            node.innerHTML = error;\n        }\n    }, {\n        key: '_removeError',\n        value: function _removeError() {\n\n            this._removeState('error');\n            this._element.querySelector('.slim-label').style.display = '';\n\n            var error = this._element.querySelector('.slim-error');\n            if (error) {\n                error.parentNode.removeChild(error);\n            }\n        }\n    }, {\n        key: '_openFileDialog',\n        value: function _openFileDialog() {\n            this._input.click();\n        }\n\n        // drop area clicked\n    }, {\n        key: '_onClick',\n        value: function _onClick(e) {\n            var _this15 = this;\n\n            var list = e.target.classList;\n            var target = e.target;\n\n            // no preview, so possible to drop file\n            if (list.contains('slim-file-hopper')) {\n                this._openFileDialog();\n                return;\n            }\n\n            // decide what button was clicked\n            switch (target.getAttribute('data-action')) {\n                case 'remove':\n                    this._options.onBeforeRemove(this, function () {\n                        _this15._doRemove();\n                    });\n                    break;\n                case 'edit':\n                    this._doEdit();\n                    break;\n                case 'download':\n                    this._doDownload();\n                    break;\n                case 'upload':\n                    this._doUpload();\n                    break;\n            }\n        }\n    }, {\n        key: '_onInvalidFileDrop',\n        value: function _onInvalidFileDrop() {\n\n            this._onInvalidFile();\n\n            this._removeState('file-over');\n\n            // animate out drip\n            var drip = this._getDrip();\n            snabbt(drip.firstChild, {\n                fromScale: [.5, .5],\n                scale: [0, 0],\n                fromOpacity: .5,\n                opacity: 0,\n                duration: 150,\n                complete: function complete() {\n\n                    // clean up transforms\n                    resetTransforms(drip.firstChild);\n                }\n            });\n        }\n    }, {\n        key: '_onInvalidFile',\n        value: function _onInvalidFile() {\n\n            var types = this._imageHopper.accept.map(getExtensionByMimeType);\n            var error = this._options.statusFileType.replace('$0', types.join(', '));\n            this._throwError(error);\n        }\n    }, {\n        key: '_onOverWeightFile',\n        value: function _onOverWeightFile() {\n\n            var error = this._options.statusFileSize.replace('$0', this._options.maxFileSize);\n            this._throwError(error);\n        }\n    }, {\n        key: '_onFileOver',\n        value: function _onFileOver(e) {\n\n            this._addState('file-over');\n            this._removeError();\n\n            // animations\n            var drip = this._getDrip();\n\n            // move around drip\n            var matrix = snabbt.createMatrix();\n            matrix.translate(e.detail.x, e.detail.y, 0);\n            snabbt.setElementTransform(drip, matrix);\n\n            // on first entry fade in blob\n            if (this._imageHopper.dragPath.length == 1) {\n\n                // show\n                drip.style.opacity = 1;\n\n                // animate in\n                snabbt(drip.firstChild, {\n                    fromOpacity: 0,\n                    opacity: .5,\n                    fromScale: [0, 0],\n                    scale: [.5, .5],\n                    duration: 150\n                });\n            }\n        }\n    }, {\n        key: '_onFileOut',\n        value: function _onFileOut(e) {\n\n            this._removeState('file-over');\n            this._removeState('file-invalid');\n            this._removeError();\n\n            // move to last position\n            var drip = this._getDrip();\n            var matrix = snabbt.createMatrix();\n            matrix.translate(e.detail.x, e.detail.y, 0);\n            snabbt.setElementTransform(drip, matrix);\n\n            // animate out\n            snabbt(drip.firstChild, {\n                fromScale: [.5, .5],\n                scale: [0, 0],\n                fromOpacity: .5,\n                opacity: 0,\n                duration: 150,\n                complete: function complete() {\n\n                    // clean up transforms\n                    resetTransforms(drip.firstChild);\n                }\n            });\n        }\n\n        /**\n         * When a file was literally dropped on the drop area\n         * @param e\n         * @private\n         */\n    }, {\n        key: '_onDropFile',\n        value: function _onDropFile(e) {\n            var _this16 = this;\n\n            this._removeState('file-over');\n\n            // get drip node reference and set to last position\n            var drip = this._getDrip();\n            var matrix = snabbt.createMatrix();\n            matrix.translate(e.detail.x, e.detail.y, 0);\n            snabbt.setElementTransform(drip, matrix);\n\n            // get element minimum 10 entries distant from the last entry so we can calculate velocity of movement\n            var l = this._imageHopper.dragPath.length;\n            var jump = this._imageHopper.dragPath[l - Math.min(10, l)];\n\n            // velocity\n            var dx = e.detail.x - jump.x;\n            var dy = e.detail.y - jump.y;\n\n            snabbt(drip, {\n                fromPosition: [e.detail.x, e.detail.y, 0],\n                position: [e.detail.x + dx, e.detail.y + dy, 0],\n                duration: 200\n            });\n\n            // animate out drip\n            snabbt(drip.firstChild, {\n\n                fromScale: [.5, .5],\n                scale: [2, 2],\n                fromOpacity: 1,\n                opacity: 0,\n                duration: 200,\n\n                complete: function complete() {\n\n                    // clean up transforms\n                    resetTransforms(drip.firstChild);\n\n                    // load dropped resource\n                    _this16._load(e.target.files[0]);\n                }\n            });\n        }\n\n        /**\n         * When a file has been selected after a click on the drop area\n         * @param e\n         * @private\n         */\n    }, {\n        key: '_onChange',\n        value: function _onChange(e) {\n\n            this._load(e.target.files[0]);\n        }\n\n        /**\n         * Loads a resource (blocking operation)\n         * @param resource\n         * @param callback(err)\n         * @private\n         */\n    }, {\n        key: '_load',\n        value: function _load(resource, callback) {\n            var _this17 = this;\n\n            // stop here\n            if (this._isBeingDestroyed) {\n                return;\n            }\n\n            // meta data\n            var file = getFileMetaData(resource);\n\n            // test if too big\n            if (file.size && this._options.maxFileSize && bytesToMegaBytes(file.size) > this._options.maxFileSize) {\n                this._onOverWeightFile();\n                if (callback) {\n                    callback('file-too-big');\n                }\n                return;\n            }\n\n            // no longer empty\n            this._removeState('empty');\n\n            // can't drop any other image\n            if (this._imageHopper) {\n                this._imageHopper.enabled = false;\n            }\n\n            // continue\n            this._data.input.name = file.name;\n            this._data.input.type = file.type;\n            this._data.input.size = file.size;\n\n            // start loading indicator\n            this._startProgressLoop();\n            this._addState('busy');\n\n            // fetch resource\n            getImageAsCanvas(resource, function (image, meta) {\n\n                // if no image, something went wrong\n                if (!image) {\n\n                    _this17._removeState('busy');\n                    _this17._stopProgressLoop();\n\n                    _this17._resetData();\n\n                    if (callback) {\n                        callback('file-not-found');\n                    }\n\n                    return;\n                }\n\n                // store file name, used to compare canvas data later on\n                image.setAttribute('data-file', file.name);\n\n                // load the image\n                _this17._loadCanvas(image, function () {\n\n                    var intro = _this17._getIntro();\n\n                    // setup base animation\n                    var animation = {\n                        fromScale: [1.25, 1.25],\n                        scale: [1, 1],\n                        fromOpacity: 0,\n                        opacity: 1,\n                        complete: function complete() {\n\n                            resetTransforms(intro);\n\n                            intro.style.opacity = 1;\n\n                            _this17._showButtons();\n\n                            _this17._stopProgressLoop();\n                            _this17._removeState('busy');\n                            _this17._addState('preview');\n\n                            if (callback) {\n                                callback(null, _this17.data);\n                            }\n                        }\n\n                    };\n\n                    // if not attached to DOM, don't animate\n                    if (_this17.isDetached()) {\n                        animation.duration = 1;\n                    } else {\n                        animation.easing = 'spring';\n                        animation.springConstant = .3;\n                        animation.springDeceleration = .7;\n                    }\n\n                    // reveal loaded image\n                    snabbt(intro, animation);\n                });\n            });\n        }\n    }, {\n        key: '_loadCanvas',\n        value: function _loadCanvas(image, ready) {\n            var _this18 = this;\n\n            // halt here if cropper is currently being destroyed\n            if (this._isBeingDestroyed) {\n                return;\n            }\n\n            // scales the drop area\n            // if is 'input' or 'free' parameter\n            if (!this._isFixedRatio()) {\n                this._ratio = image.height / image.width;\n                this._scaleDropArea(this._ratio);\n            }\n\n            // store raw data\n            this._data.input.image = image;\n            this._data.input.width = image.width;\n            this._data.input.height = image.height;\n\n            if (this._initialCrop) {\n\n                // use initial supplied crop rectangle\n                this._data.actions.crop = clone(this._initialCrop);\n                this._data.actions.crop.type = CropType.INITIAL;\n\n                // clear initial crop, it's no longer useful\n                this._initialCrop = null;\n            } else {\n                // get automagical crop rectangle\n                this._data.actions.crop = getAutoCropRect(image.width, image.height, this._ratio);\n                this._data.actions.crop.type = CropType.AUTO;\n            }\n\n            // if max size set\n            if (this._options.size) {\n                this._data.actions.size = {\n                    width: this._options.size.width,\n                    height: this._options.size.height\n                };\n            }\n\n            // do initial auto transform\n            this._applyTransforms(image, function (transformedImage) {\n\n                var intro = _this18._getIntro();\n                var scalar = intro.offsetWidth / transformedImage.width;\n\n                // store data, if has preview image this prevents initial load from pushing\n                var doUpload = false;\n\n                // can only do auto upload when service is defined and push is enabled...\n                if (_this18._options.service && _this18._options.push) {\n\n                    // ...and is not transformation of initial image\n                    if (!_this18._hasInitialImage) {\n                        doUpload = true;\n                    }\n                }\n\n                _this18._save(function () {}, doUpload);\n\n                // show intro animation\n                intro.src = cloneCanvasScaled(transformedImage, scalar).toDataURL();\n                intro.onload = function () {\n\n                    intro.onload = null;\n\n                    // bail out if we've been cleaned up\n                    if (_this18._isBeingDestroyed) {\n                        return;\n                    }\n\n                    if (ready) {\n                        ready();\n                    }\n                };\n            });\n        }\n    }, {\n        key: '_applyTransforms',\n        value: function _applyTransforms(image, ready) {\n            var _this19 = this;\n\n            transformCanvas(image, this._data.actions, function (transformedImage) {\n\n                _this19._data.output.width = transformedImage.width;\n                _this19._data.output.height = transformedImage.height;\n                _this19._data.output.image = transformedImage;\n\n                _this19._onTransformCanvas(_this19._data, function (transformedData) {\n\n                    _this19._data = transformedData;\n\n                    ready(_this19._data.output.image);\n                });\n            });\n        }\n    }, {\n        key: '_onTransformCanvas',\n        value: function _onTransformCanvas(data, ready) {\n\n            this._options.onTransform(cloneData(data), ready);\n        }\n\n        /**\n         * Creates the editor nodes\n         * @private\n         */\n    }, {\n        key: '_appendEditor',\n        value: function _appendEditor() {\n            var _this20 = this;\n\n            // we already have an editor\n            if (this._imageEditor) {\n                return;\n            }\n\n            // add editor\n            this._imageEditor = new ImageEditor(create('div'), {\n                minSize: this._options.minSize,\n\n                buttonConfirmClassName: 'slim-btn-confirm',\n                buttonCancelClassName: 'slim-btn-cancel',\n\n                buttonConfirmLabel: this._options.buttonConfirmLabel,\n                buttonCancelLabel: this._options.buttonCancelLabel,\n\n                buttonConfirmTitle: this._options.buttonConfirmTitle,\n                buttonCancelTitle: this._options.buttonCancelTitle\n\n            });\n\n            // listen to events\n            ImageEditorEvents.forEach(function (e) {\n                _this20._imageEditor.element.addEventListener(e, _this20);\n            });\n        }\n    }, {\n        key: '_scaleDropArea',\n        value: function _scaleDropArea(ratio) {\n            var node = this._getRatioSpacerElement();\n            node.style.marginBottom = ratio * 100 + '%';\n            this._element.setAttribute('data-ratio', '1:' + ratio);\n        }\n\n        /**\n         * Data Layer\n         * @private\n         */\n        // image editor closed\n    }, {\n        key: '_onCancel',\n        value: function _onCancel(e) {\n\n            this._removeState('editor');\n\n            this._showButtons();\n\n            this._hideEditor();\n        }\n\n        // user confirmed changes\n    }, {\n        key: '_onConfirm',\n        value: function _onConfirm(e) {\n            var _this21 = this;\n\n            this._removeState('editor');\n\n            this._startProgressLoop();\n            this._addState('busy');\n\n            // clear data\n            this._output.value = '';\n\n            // apply new action object to this._data\n            this._data.actions.crop = e.detail.crop;\n            this._data.actions.crop.type = CropType.MANUAL;\n\n            // do transforms\n            this._applyTransforms(this._data.input.image, function (transformedImage) {\n\n                // set new image result\n                var images = _this21._getInOut();\n                var intro = images[0].className === 'out' ? images[0] : images[1];\n                var outro = intro === images[0] ? images[1] : images[0];\n\n                intro.className = 'in';\n                intro.style.opacity = '0';\n                intro.style.zIndex = '2';\n                outro.className = 'out';\n                outro.style.zIndex = '1';\n\n                // new image get's\n                intro.src = cloneCanvasScaled(transformedImage, intro.offsetWidth / transformedImage.width).toDataURL();\n                intro.onload = function () {\n\n                    intro.onload = null;\n\n                    // scale the dropzone\n                    if (_this21._options.ratio === 'free') {\n                        _this21._ratio = intro.naturalHeight / intro.naturalWidth;\n                        _this21._scaleDropArea(_this21._ratio);\n                    }\n\n                    // close the editor\n                    _this21._hideEditor();\n\n                    // wait a tiny bit so animations sync up nicely\n                    setTimeout(function () {\n\n                        // show the preview\n                        _this21._showPreview(intro, function () {\n\n                            // if\n                            // - service set\n                            // - and we are pushing\n                            // we will upload\n                            var willUpload = _this21._options.service && _this21._options.push;\n\n                            // save the data\n                            _this21._save(function (err, res) {\n\n                                // done!\n                                _this21._toggleButton('upload', true);\n\n                                _this21._stopProgressLoop();\n                                _this21._removeState('busy');\n\n                                _this21._showButtons();\n\n                                // if server returns a path, use server path for new image\n                                if (!res || !res.path) {\n                                    return;\n                                }\n                                intro.src = res.path;\n                            }, willUpload);\n                        });\n                    }, 250);\n                };\n            });\n        }\n    }, {\n        key: '_save',\n        value: function _save() {\n            var _this22 = this;\n\n            var callback = arguments.length <= 0 || arguments[0] === undefined ? function () {} : arguments[0];\n            var allowUpload = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];\n\n            // flatten data also turns canvas into data uri's\n            var data = flattenData(this._data, this._options.post);\n\n            // decide if we need to\n            // - A. Upload the data\n            // - B. Store the data in an output field\n\n            // user has final option to alter data\n            this._options.onSave(data, function (data) {\n\n                // if output field defined and no service store for sync submit\n                if (_this22._output && !_this22._options.service) {\n                    _this22._store(data);\n                }\n\n                // is remote service defined up async\n                if (_this22._options.service && allowUpload) {\n                    _this22._upload(data, function (err, res) {\n\n                        // store response\n                        if (!err) {\n                            _this22._storeServerResponse(res);\n                        }\n\n                        // upload returned\n                        _this22._options.onComplete(err, res);\n\n                        // woo\n                        callback(err, res);\n                    });\n                }\n\n                // if no service, we're done here\n                if (!_this22._options.service || !allowUpload) {\n                    callback();\n                }\n            });\n        }\n\n        // stores active file information in hidden output field\n    }, {\n        key: '_storeServerResponse',\n        value: function _storeServerResponse(data) {\n\n            // remove required flag\n            if (this._isRequired) {\n                this._input.required = false;\n            }\n\n            // store data returned from server\n            this._data.server = data;\n\n            // sync with output value\n            this._output.value = typeof data === 'object' ? JSON.stringify(this._data.server) : data;\n        }\n\n        // stores data in output field\n    }, {\n        key: '_store',\n        value: function _store(data) {\n\n            if (this._isRequired) {\n                this._input.required = false;\n            }\n\n            this._output.value = JSON.stringify(data);\n        }\n\n        // uploads given data to server\n    }, {\n        key: '_upload',\n        value: function _upload(data, callback) {\n            var _this23 = this;\n\n            var fd = new FormData();\n            fd.append(this._output.name, JSON.stringify(data));\n\n            var statusNode = this._element.querySelector('.slim-upload-status');\n\n            send(this._options.service,\n\n            // data\n            fd,\n\n            // progress\n            function (loaded, total) {\n\n                _this23._updateProgress(loaded / total);\n            },\n\n            // success\n            function (obj) {\n\n                setTimeout(function () {\n\n                    statusNode.innerHTML = _this23._options.statusUploadSuccess;\n                    statusNode.setAttribute('data-state', 'success');\n                    statusNode.style.opacity = 1;\n\n                    // hide status update after 2 seconds\n                    setTimeout(function () {\n                        statusNode.style.opacity = 0;\n                    }, 2000);\n                }, 250);\n\n                callback(null, obj);\n            },\n\n            // error\n            function (status) {\n\n                var html = '';\n                if (status === 'file-too-big') {\n                    html = _this23._options.statusContentLength;\n                } else {\n                    html = _this23._options.statusUnknownResponse;\n                }\n\n                // when an error occurs the status update is not automatically hidden\n                setTimeout(function () {\n\n                    statusNode.innerHTML = html;\n                    statusNode.setAttribute('data-state', 'error');\n                    statusNode.style.opacity = 1;\n                }, 250);\n\n                callback(status);\n            });\n        }\n    }, {\n        key: '_showEditor',\n        value: function _showEditor() {\n\n            SlimPopover.show();\n\n            this._imageEditor.show();\n        }\n    }, {\n        key: '_hideEditor',\n        value: function _hideEditor() {\n\n            this._imageEditor.hide();\n\n            setTimeout(function () {\n\n                SlimPopover.hide();\n            }, 250);\n        }\n\n        /**\n         * Animations\n         */\n    }, {\n        key: '_showPreview',\n        value: function _showPreview(intro, callback) {\n\n            snabbt(intro, {\n\n                fromPosition: [0, 50, 0],\n                position: [0, 0, 0],\n\n                fromScale: [1.5, 1.5],\n                scale: [1, 1],\n\n                fromOpacity: 0,\n                opacity: 1,\n\n                easing: 'spring',\n                springConstant: .3,\n                springDeceleration: .7,\n\n                complete: function complete() {\n\n                    resetTransforms(intro);\n\n                    if (callback) {\n                        callback();\n                    }\n                }\n\n            });\n        }\n    }, {\n        key: '_hideResult',\n        value: function _hideResult(callback) {\n\n            var intro = this._getIntro();\n            if (!intro) {\n                return;\n            }\n\n            snabbt(intro, {\n\n                fromScale: [1, 1],\n                scale: [.5, .5],\n\n                fromOpacity: 1,\n                opacity: 0,\n\n                easing: 'spring',\n                springConstant: .3,\n                springDeceleration: .75,\n\n                complete: function complete() {\n                    resetTransforms(intro);\n\n                    if (callback) {\n                        callback();\n                    }\n                }\n\n            });\n        }\n    }, {\n        key: '_showButtons',\n        value: function _showButtons(callback) {\n\n            this._btnGroup.style.display = '';\n\n            // setup animation\n            var animation = {\n                fromScale: [.5, .5],\n                scale: [1, 1],\n                fromPosition: [0, 10, 0],\n                position: [0, 0, 0],\n                fromOpacity: 0,\n                opacity: 1,\n                complete: function complete() {\n                    resetTransforms(this);\n                },\n                allDone: function allDone() {\n                    if (callback) {\n                        callback();\n                    }\n                }\n            };\n\n            // don't animate when detached\n            if (this.isDetached()) {\n                animation.duration = 1;\n            } else {\n                animation.delay = function (i) {\n                    return 250 + i * 50;\n                };\n                animation.easing = 'spring';\n                animation.springConstant = .3;\n                animation.springDeceleration = .85;\n            }\n\n            snabbt(this._btnGroup.childNodes, animation);\n        }\n    }, {\n        key: '_hideButtons',\n        value: function _hideButtons(callback) {\n            var _this24 = this;\n\n            var animation = {\n                fromScale: [1, 1],\n                scale: [.85, .85],\n                fromOpacity: 1,\n                opacity: 0,\n                allDone: function allDone() {\n                    _this24._btnGroup.style.display = 'none';\n                    if (callback) {\n                        callback();\n                    }\n                }\n            };\n\n            // don't animate when detached\n            if (this.isDetached()) {\n                animation.duration = 1;\n            } else {\n                animation.easing = 'spring';\n                animation.springConstant = .3;\n                animation.springDeceleration = .75;\n            }\n\n            // go hide the buttons\n            snabbt(this._btnGroup.childNodes, animation);\n        }\n    }, {\n        key: '_hideStatus',\n        value: function _hideStatus() {\n\n            var statusNode = this._element.querySelector('.slim-upload-status');\n            statusNode.style.opacity = 0;\n        }\n    }, {\n        key: '_doEdit',\n        value: function _doEdit() {\n            var _this25 = this;\n\n            // if no input data available, can't edit anything\n            if (!this._data.input.image) {\n                return;\n            }\n\n            // now in editor mode\n            this._addState('editor');\n\n            // create editor (if not already created)\n            if (!this._imageEditor) {\n                this._appendEditor();\n            }\n\n            // append to popover\n            SlimPopover.inner = this._imageEditor.element;\n\n            // read the data\n            this._imageEditor.open(\n\n            // send copy of canvas to the editor\n            cloneCanvas(this._data.input.image),\n\n            // determine ratio\n            this._options.ratio === 'free' ? null : this._ratio,\n\n            // the initial crop to show\n            this._data.actions.crop,\n\n            // handle editor load\n            function () {\n\n                _this25._showEditor();\n\n                _this25._hideButtons();\n\n                _this25._hideStatus();\n            });\n        }\n    }, {\n        key: '_doRemove',\n        value: function _doRemove() {\n            var _this26 = this;\n\n            // cannot remove when is only one image\n            if (this._isImageOnly()) {\n                return;\n            }\n\n            this._clearState();\n            this._addState('empty');\n\n            this._hasInitialImage = false;\n            this._imageHopper.enabled = true;\n\n            if (this._isRequired) {\n                this._input.required = true;\n            }\n\n            var out = this._getOutro();\n            if (out) {\n                out.style.opacity = '0';\n            }\n\n            // get public available clone of data\n            var data = this.data;\n\n            // now reset all data\n            this._resetData();\n\n            setTimeout(function () {\n\n                if (_this26._isBeingDestroyed) {\n                    return;\n                }\n\n                _this26._hideButtons(function () {\n\n                    _this26._toggleButton('upload', true);\n                });\n\n                _this26._hideStatus();\n\n                _this26._hideResult();\n\n                _this26._options.onRemove(_this26, data);\n            }, this.isDetached() ? 0 : 250);\n\n            return data;\n        }\n    }, {\n        key: '_doUpload',\n        value: function _doUpload(callback) {\n            var _this27 = this;\n\n            // if no input data available, can't upload anything\n            if (!this._data.input.image) {\n                return;\n            }\n\n            this._addState('upload');\n            this._startProgress();\n\n            this._hideButtons(function () {\n\n                // block upload button\n                _this27._toggleButton('upload', false);\n\n                _this27._save(function (err, res) {\n\n                    _this27._removeState('upload');\n                    _this27._stopProgress();\n\n                    if (callback) {\n                        callback(err, res);\n                    }\n\n                    if (err) {\n                        _this27._toggleButton('upload', true);\n                    }\n\n                    _this27._showButtons();\n                });\n            });\n        }\n    }, {\n        key: '_doDownload',\n        value: function _doDownload() {\n\n            var image = this._data.output.image;\n            if (!image) {\n                return;\n            }\n\n            var filename = this._data.input.name;\n            var mimetype = this._data.input.type;\n\n            image.toBlob(function (blob) {\n\n                var link = create('a');\n                link.download = filename;\n                link.href = URL.createObjectURL(blob);\n                link.click();\n            }, mimetype);\n        }\n    }, {\n        key: '_doDestroy',\n        value: function _doDestroy() {\n            var _this28 = this;\n\n            // set destroy flag to halt any running functionality\n            this._isBeingDestroyed = true;\n\n            // this removes the image hopper if it's attached\n            if (this._imageHopper) {\n                HopperEvents.forEach(function (e) {\n                    _this28._imageHopper.element.removeEventListener(e, _this28);\n                });\n                this._imageHopper.destroy();\n            }\n\n            // this block removes the image editor\n            if (this._imageEditor) {\n                ImageEditorEvents.forEach(function (e) {\n                    _this28._imageEditor.element.removeEventListener(e, _this28);\n                });\n                this._imageEditor.destroy();\n            }\n\n            // remove button event listeners\n            nodeListToArray(this._btnGroup.children).forEach(function (btn) {\n                btn.removeEventListener('click', _this28);\n            });\n\n            // stop listening to input\n            this._input.removeEventListener('change', this);\n\n            // detect if was wrapped, if so, remove wrapping (needs to have parent node)\n            if (this._element !== this._originalElement && this._element.parentNode) {\n                this._element.parentNode.replaceChild(this._originalElement, this._element);\n            }\n\n            // restore HTML of original element\n            this._originalElement.innerHTML = this._originalElementInner;\n\n            // get current attributes and remove all, then add original attributes\n            function matchesAttributeInList(a, attributes) {\n                return attributes.filter(function (attr) {\n                    return a.name === attr.name && a.value === attr.value;\n                }).length !== 0;\n            }\n\n            var attributes = getElementAttributes(this._originalElement);\n            attributes.forEach(function (attribute) {\n\n                // if attribute  is contained in original element attribute list and is the same, don't remove\n                if (matchesAttributeInList(attribute, _this28._originalElementAttributes)) {\n                    return;\n                }\n\n                // else remove\n                _this28._originalElement.removeAttribute(attribute.name);\n            });\n\n            this._originalElementAttributes.forEach(function (attribute) {\n\n                // attribute was never removed\n                if (matchesAttributeInList(attribute, attributes)) {\n                    return;\n                }\n\n                // add attribute\n                _this28._originalElement.setAttribute(attribute.name, attribute.value);\n            });\n\n            // now destroyed this counter so the total Slim count can be lowered\n            SlimCount = Math.max(0, SlimCount - 1);\n\n            // if slim count has reached 0 it's time to clean up the popover\n            if (SlimPopover && SlimCount === 0) {\n                SlimPopover.destroy();\n                SlimPopover = null;\n            }\n        }\n    }, {\n        key: 'data',\n\n        /**\n         * Public API\n         */\n\n        // properties\n        get: function get() {\n            return cloneData(this._data);\n        }\n    }], [{\n        key: 'options',\n        value: function options() {\n\n            var defaults = {\n\n                // edit button is enabled by default\n                edit: true,\n\n                // ratio of crop by default is the same as input image ratio\n                ratio: 'free',\n\n                // dimensions to resize the resulting image to\n                size: null,\n\n                // initial crop settings for example: {x:0, y:0, width:100, height:100}\n                crop: null,\n\n                // post these values\n                post: ['output', 'actions'],\n\n                // call this service to submit cropped data\n                service: null,\n\n                // when service is set, and this is set to true, Soon will auto upload all crops (also auto crops)\n                push: false,\n\n                // default fallback name for field\n                defaultInputName: 'slim[]',\n\n                // minimum size of cropped area object with width and height property\n                minSize: {\n                    width: 100,\n                    height: 100\n                },\n\n                // maximum file size in MB to upload\n                maxFileSize: null,\n\n                // render download link\n                download: false,\n\n                // label HTML to show inside drop area\n                label: '<p>Drop your image here</p>',\n\n                // error messages\n                statusFileType: '<p>Invalid file type, expects: $0.</p>',\n                statusFileSize: '<p>File is too big, maximum file size: $0 MB.</p>',\n                statusNoSupport: '<p>Your browser does not support image cropping.</p>',\n                statusContentLength: '<span class=\"slim-upload-status-icon\"></span> The file is probably too big',\n                statusUnknownResponse: '<span class=\"slim-upload-status-icon\"></span> An unknown error occurred',\n                statusUploadSuccess: '<span class=\"slim-upload-status-icon\"></span> Saved',\n\n                // callback methods\n                onInit: function onInit(slim) {},\n                onTransform: function onTransform(data, cb) {\n                    cb(data);\n                },\n                onSave: function onSave(data, cb) {\n                    cb(data);\n                },\n                onComplete: function onComplete(err, res) {},\n                onBeforeRemove: function onBeforeRemove(slim, cb) {\n                    cb();\n                },\n                onRemove: function onRemove(slim, data) {}\n\n            };\n\n            // add default button labels\n            SlimButtons.concat(ImageEditorButtons).forEach(function (btn) {\n                var capitalized = capitalizeFirstLetter(btn);\n                defaults['button' + capitalized + 'ClassName'] = null;\n                defaults['button' + capitalized + 'Label'] = capitalized;\n                defaults['button' + capitalized + 'Title'] = null;\n            });\n\n            return defaults;\n        }\n    }]);\n\n    return Slim;\n})();\n\n(function () {\n\n    var instances = [];\n\n    var indexOfElement = function indexOfElement(element) {\n        var i = 0;\n        var l = instances.length;\n        for (; i < l; i++) {\n            if (instances[i].isAttachedTo(element)) {\n                return i;\n            }\n        }\n        return -1;\n    };\n\n    function getData(el, attribute) {\n        return el.getAttribute('data-' + attribute);\n    }\n\n    function toAttribute(property) {\n        return property.replace(/([a-z](?=[A-Z]))/g, '$1-').toLowerCase();\n    }\n\n    function clone(value) {\n        if (typeof value === 'object') {\n            return JSON.parse(JSON.stringify(value));\n        }\n        return value;\n    }\n\n    function toLabel(v) {\n        // if value set, use as label\n        if (v) {\n            return '<p>' + v + '</p>';\n        }\n\n        // else use default text\n        return null;\n    }\n\n    function toFunctionReference(name) {\n        var ref = window;\n        var levels = name.split('.');\n        levels.forEach(function (level, index) {\n            ref = ref[levels[index]];\n        });\n        return ref;\n    }\n\n    var passThrough = function passThrough(e, v) {\n        return v;\n    };\n    var defaultFalse = function defaultFalse(e, v) {\n        return v === 'true';\n    };\n    var defaultTrue = function defaultTrue(e, v) {\n        return v ? v === 'true' : true;\n    };\n    var defaultLabel = function defaultLabel(e, v) {\n        return toLabel(v);\n    };\n    var defaultFunction = function defaultFunction(e, v) {\n        return v ? toFunctionReference(v) : null;\n    };\n    var defaultSize = function defaultSize(e, v) {\n        if (!v) {\n            return null;\n        }\n        var parts = intSplit(v, ',');\n        return { width: parts[0], height: parts[1] };\n    };\n\n    var toRect = function toRect(e, v) {\n        if (!v) {\n            return null;\n        }\n        var obj = {};\n        v.split(',').map(function (p) {\n            return parseInt(p, 10);\n        }).forEach(function (v, i) {\n            obj[Rect[i]] = v;\n        });\n        return obj;\n    };\n\n    var defaults = {\n\n        // is user allowed to download the cropped image?\n        'download': defaultFalse,\n\n        // is user allowed to edit the cropped image?\n        'edit': defaultTrue,\n\n        // minimum crop size in pixels of original image\n        'minSize': defaultSize,\n\n        // the final size of the output image\n        'size': defaultSize,\n\n        // url to post to\n        'service': function service(e, v) {\n            return typeof v === 'undefined' ? null : v;\n        },\n\n        // set auto push mode\n        'push': defaultFalse,\n\n        // set crop rect\n        'crop': toRect,\n\n        // what to post\n        'post': function post(e, v) {\n            if (!v) {\n                return null;\n            }\n            return v.split(',').map(function (item) {\n                return item.trim();\n            });\n        },\n\n        // default input name\n        'defaultInputName': passThrough,\n\n        // the ratio of the crop\n        'ratio': function ratio(e, v) {\n            if (!v) {\n                return null;\n            }\n            return v;\n        },\n\n        // maximum file size\n        'maxFileSize': function maxFileSize(e, v) {\n            if (!v) {\n                return null;\n            }\n            return parseFloat(v);\n        },\n\n        // default labels\n        'label': defaultLabel\n\n    };\n\n    // labels\n    ['FileSize', 'FileType', 'NoSupport'].forEach(function (status) {\n        defaults['status' + status] = defaultLabel;\n    });\n\n    // status\n    ['ContentLength', 'UnknownResponse', 'UploadSuccess'].forEach(function (status) {\n        defaults['status' + status] = passThrough;\n    });\n\n    // the events to bind to\n    ['Init', 'Transform', 'Save', 'Complete', 'BeforeRemove', 'Remove'].forEach(function (cb) {\n        defaults['on' + cb] = defaultFunction;\n    });\n\n    // button defaults\n    var buttonOptions = ['ClassName', 'Label', 'Title'];\n    SlimButtons.concat(ImageEditorButtons).forEach(function (btn) {\n        var capitalized = capitalizeFirstLetter(btn);\n        buttonOptions.forEach(function (opt) {\n            defaults['button' + capitalized + opt] = passThrough;\n        });\n    });\n\n    Slim.supported = (function () {\n\n        return typeof window.FileReader !== 'undefined';\n    })();\n\n    Slim.parse = function (context) {\n\n        var elements;\n        var element;\n        var i;\n        var options;\n        var value;\n        var prop;\n        var croppers = [];\n\n        // find all crop elements and bind Crop behavior\n        elements = context.querySelectorAll('.slim:not([data-state])');\n        i = elements.length;\n\n        while (i--) {\n\n            element = elements[i];\n            options = {};\n\n            for (prop in defaults) {\n                if (!defaults.hasOwnProperty(prop)) {\n                    continue;\n                }\n                value = defaults[prop](element, getData(element, toAttribute(prop)));\n                options[prop] = value === null ? clone(Slim.options()[prop]) : value;\n            }\n\n            croppers.push(Slim.create(element, options));\n        }\n\n        return croppers;\n    };\n\n    Slim.find = function (element) {\n        var result = instances.filter(function (instance) {\n            return instance.isAttachedTo(element);\n        });\n        return result ? result[0] : null;\n    };\n\n    Slim.create = function (element, options) {\n\n        // if already in array, can't create another slim\n        if (Slim.find(element)) {\n            return;\n        }\n\n        // instance\n        var slim = new Slim(element, options);\n\n        // add new slim\n        instances.push(slim);\n\n        // return the slim instance\n        return slim;\n    };\n\n    Slim.destroy = function (element) {\n\n        var index = indexOfElement(element);\n\n        if (index < 0) {\n            return false;\n        }\n\n        instances[index].destroy();\n        instances[index] = null;\n        instances.splice(index, 1);\n        return true;\n    };\n})();\n    return Slim;\n}();\n\n    // Auto parses document for Slim croppers\n    function kick() {\n        root.Slim.parse(document);\n    }\n\n    if (document.readyState !== 'loading') {\n        kick();\n    }\n    else {\n        document.addEventListener('DOMContentLoaded',kick);\n    }\n\n}(this));"],"sourceRoot":"/source/"}